/* tslint:disable */
/* eslint-disable */
/**
 * eZmax API Definition
 * This API expose all the functionnalities for the eZmax and eZsign application.  We provide SDKs for customers. They are generated using OpenAPI codegen, we encourage customers to use them as we also provide samples for them.  You can choose to build your own implementation manually or can use any compatible OpenAPI 3.0 generator like Swagger Codegen, OpenAPI codegen or any commercial generators.  If you need helping understanding how to use this API, don\'t waste too much time looking for it. Contact support-api@ezmax.ca, we\'re here to help. We are developpers so we know programmers don\'t like bad documentation. If you don\'t find what you need in the documentation, let us know, we\'ll improve it and put you rapidly up on track.  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0.26
 * Contact: support-api@ezmax.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Response for the /1/object/activesession/getCurrent API Request
 * @export
 * @interface ActivesessionGetCurrentV1Response
 */
export interface ActivesessionGetCurrentV1Response {
    /**
     * 
     * @type {ActivesessionGetCurrentV1ResponseMPayload}
     * @memberof ActivesessionGetCurrentV1Response
     */
    mPayload: ActivesessionGetCurrentV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof ActivesessionGetCurrentV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof ActivesessionGetCurrentV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/activesession/getCurrent API Request
 * @export
 * @interface ActivesessionGetCurrentV1ResponseMPayload
 */
export interface ActivesessionGetCurrentV1ResponseMPayload {
    /**
     * The customer code specific to the client in which the API request is being made
     * @type {string}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    sCustomerCode: string;
    /**
     * The type of session used for the API request call
     * @type {string}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    eActivesessionSessiontype: ActivesessionGetCurrentV1ResponseMPayloadEActivesessionSessiontypeEnum;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    fkiLanguageID: number;
    /**
     * The name of the active Company in the current language
     * @type {string}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    sCompanyNameX: string;
    /**
     * The name of the active Department in the current language
     * @type {string}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    sDepartmentNameX: string;
    /**
     * An Array of Registered modules.  These are the modules that are Licensed to be used by the User or the API Key.
     * @type {Array<string>}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    a_RegisteredModules: Array<string>;
    /**
     * An array of permissions granted to the user or api key
     * @type {Array<number>}
     * @memberof ActivesessionGetCurrentV1ResponseMPayload
     */
    a_Permissions: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum ActivesessionGetCurrentV1ResponseMPayloadEActivesessionSessiontypeEnum {
    Normal = 'Normal'
}

/**
 * An Address Object
 * @export
 * @interface AddressRequest
 */
export interface AddressRequest {
    /**
     * The unique ID of the Addresstype.  Valid values:  |Value|Description| |-|-| |1|Office| |2|Home| |3|Real Estate Invoice| |4|Invoicing| |5|Shipping|
     * @type {number}
     * @memberof AddressRequest
     */
    fkiAddresstypeID: number;
    /**
     * The Civic number.
     * @type {string}
     * @memberof AddressRequest
     */
    sAddressCivic: string;
    /**
     * The Street Name
     * @type {string}
     * @memberof AddressRequest
     */
    sAddressStreet: string;
    /**
     * The Suite or appartment number
     * @type {string}
     * @memberof AddressRequest
     */
    sAddressSuite: string;
    /**
     * The City name
     * @type {string}
     * @memberof AddressRequest
     */
    sAddressCity: string;
    /**
     * The unique ID of the Province.  Here are some common values (Complete list must be retrieved from API):  |Value|Description| |-|-| |1|(Canada) Alberta |2|(Canada) British Columbia| |3|(Canada) Manitoba| |3|(Canada) Manitoba| |4|(Canada) New Brunswick| |5|(Canada) Newfoundland| |6|(Canada) Northwest Territories| |7|(Canada) Nova Scotia| |8|(Canada) Nunavut| |9|(Canada) Ontario| |10|(Canada) Prince Edward Island| |11|(Canada) Quebec| |12|(Canada) Saskatchewan| |13|(Canada) Yukon| |14|(United-States) Alabama| |15|(United-States) Alaska| |16|(United-States) Arizona| |17|(United-States) Arkansas| |18|(United-States) California| |19|(United-States) Colorado| |20|(United-States) Connecticut| |21|(United-States) Delaware| |22|(United-States) District of Columbia| |23|(United-States) Florida| |24|(United-States) Georgia| |25|(United-States) Hawaii| |26|(United-States) Idaho| |27|(United-States) Illinois| |28|(United-States) Indiana| |29|(United-States) Iowa| |30|(United-States) Kansas| |31|(United-States) Kentucky| |32|(United-States) Louisiane| |33|(United-States) Maine| |34|(United-States) Maryland| |35|(United-States) Massachusetts| |36|(United-States) Michigan| |37|(United-States) Minnesota| |38|(United-States) Mississippi| |39|(United-States) Missouri| |40|(United-States) Montana| |41|(United-States) Nebraska| |42|(United-States) Nevada| |43|(United-States) New Hampshire| |44|(United-States) New Jersey| |45|(United-States) New Mexico| |46|(United-States) New York| |47|(United-States) North Carolina| |48|(United-States) North Dakota| |49|(United-States) Ohio| |50|(United-States) Oklahoma| |51|(United-States) Oregon| |52|(United-States) Pennsylvania| |53|(United-States) Rhode Island| |54|(United-States) South Carolina| |55|(United-States) South Dakota| |56|(United-States) Tennessee| |57|(United-States) Texas| |58|(United-States) Utah| |60|(United-States) Vermont| |59|(United-States) Virginia| |61|(United-States) Washington| |62|(United-States) West Virginia| |63|(United-States) Wisconsin| |64|(United-States) Wyoming|
     * @type {number}
     * @memberof AddressRequest
     */
    fkiProvinceID: number;
    /**
     * The unique ID of the Country.  Here are some common values (Complete list must be retrieved from API):  |Value|Description| |-|-| |1|Canada| |2|United-States|
     * @type {number}
     * @memberof AddressRequest
     */
    fkiCountryID: number;
    /**
     * The Postal/Zip Code  The value must be entered without spaces
     * @type {string}
     * @memberof AddressRequest
     */
    sAddressZip: string;
}
/**
 * Request for the /1/object/apikey/createObject API Request
 * @export
 * @interface ApikeyCreateObjectV1Request
 */
export interface ApikeyCreateObjectV1Request {
    /**
     * 
     * @type {ApikeyRequest}
     * @memberof ApikeyCreateObjectV1Request
     */
    objApikey?: ApikeyRequest;
    /**
     * 
     * @type {ApikeyRequestCompound}
     * @memberof ApikeyCreateObjectV1Request
     */
    objApikeyCompound?: ApikeyRequestCompound;
}
/**
 * Response for the /1/object/apikey/createObject API Request
 * @export
 * @interface ApikeyCreateObjectV1Response
 */
export interface ApikeyCreateObjectV1Response {
    /**
     * 
     * @type {ApikeyCreateObjectV1ResponseMPayload}
     * @memberof ApikeyCreateObjectV1Response
     */
    mPayload: ApikeyCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof ApikeyCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof ApikeyCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/apikey/createObject API Request
 * @export
 * @interface ApikeyCreateObjectV1ResponseMPayload
 */
export interface ApikeyCreateObjectV1ResponseMPayload {
    /**
     * 
     * @type {Array<ApikeyResponse>}
     * @memberof ApikeyCreateObjectV1ResponseMPayload
     */
    a_objApikey: Array<ApikeyResponse>;
}
/**
 * An Apikey Object
 * @export
 * @interface ApikeyRequest
 */
export interface ApikeyRequest {
    /**
     * The unique ID of the User
     * @type {number}
     * @memberof ApikeyRequest
     */
    fkiUserID: number;
    /**
     * 
     * @type {MultilingualApikeyDescription}
     * @memberof ApikeyRequest
     */
    objApikeyDescription: MultilingualApikeyDescription;
}
/**
 * An Apikey Object and children to create a complete structure
 * @export
 * @interface ApikeyRequestCompound
 */
export interface ApikeyRequestCompound {
    /**
     * The unique ID of the User
     * @type {number}
     * @memberof ApikeyRequestCompound
     */
    fkiUserID: number;
    /**
     * 
     * @type {MultilingualApikeyDescription}
     * @memberof ApikeyRequestCompound
     */
    objApikeyDescription: MultilingualApikeyDescription;
}
/**
 * An Apikey Object
 * @export
 * @interface ApikeyResponse
 */
export interface ApikeyResponse {
    /**
     * 
     * @type {MultilingualApikeyDescription}
     * @memberof ApikeyResponse
     */
    objApikeyDescription: MultilingualApikeyDescription;
    /**
     * The secret token for the API key.  This will be returned only on creation.
     * @type {string}
     * @memberof ApikeyResponse
     */
    sComputedToken?: string;
    /**
     * The unique ID of the Apikey
     * @type {number}
     * @memberof ApikeyResponse
     */
    pkiApikeyID: number;
    /**
     * 
     * @type {CommonAudit}
     * @memberof ApikeyResponse
     */
    objAudit: CommonAudit;
}
/**
 * An Attempt object
 * @export
 * @interface AttemptResponse
 */
export interface AttemptResponse {
    /**
     * Represent a Date Time. The timezone is the one configured in the User\'s profile.
     * @type {string}
     * @memberof AttemptResponse
     */
    dtAttemptStart: string;
    /**
     * The Success or Failure message of the attempt when we tried to call the URL to deliver the webhook event.
     * @type {string}
     * @memberof AttemptResponse
     */
    sAttemptResult: string;
    /**
     * The number of second it took to process the webhook or get an error
     * @type {number}
     * @memberof AttemptResponse
     */
    iAttemptDuration: number;
}
/**
 * Gives informations about the user that created the object and the last user to have modified it.  If the object was never modified after creation, both Created and Modified informations will be the same.  Apikey details will only be provided if the changes were made by an API key.  
 * @export
 * @interface CommonAudit
 */
export interface CommonAudit {
    /**
     * The id of the User that created the object.
     * @type {number}
     * @memberof CommonAudit
     */
    fkiUserIDCreated: number;
    /**
     * The id of the User that made the last modification on the object.
     * @type {number}
     * @memberof CommonAudit
     */
    fkiUserIDModified: number;
    /**
     * The id of the API Key that created the object.
     * @type {number}
     * @memberof CommonAudit
     */
    fkiApikeyIDCreated?: number;
    /**
     * The id of the API Key that made the last modification on the object.
     * @type {number}
     * @memberof CommonAudit
     */
    fkiApikeyIDModified?: number;
    /**
     * Represent a Date Time. The timezone is the one configured in the User\'s profile.
     * @type {string}
     * @memberof CommonAudit
     */
    dtCreatedDate: string;
    /**
     * Represent a Date Time. The timezone is the one configured in the User\'s profile.
     * @type {string}
     * @memberof CommonAudit
     */
    dtModifiedDate: string;
}
/**
 * Response for the /1/object/xxx/getAutocomplete API Request
 * @export
 * @interface CommonGetAutocompleteV1Response
 */
export interface CommonGetAutocompleteV1Response {
    /**
     * 
     * @type {Array<CommonGetAutocompleteV1ResponseMPayload>}
     * @memberof CommonGetAutocompleteV1Response
     */
    mPayload: Array<CommonGetAutocompleteV1ResponseMPayload>;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof CommonGetAutocompleteV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof CommonGetAutocompleteV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Generic Autocomplete Response
 * @export
 * @interface CommonGetAutocompleteV1ResponseMPayload
 */
export interface CommonGetAutocompleteV1ResponseMPayload {
    /**
     * The Category (ie group) for the dropdown or an empty string if not categorized
     * @type {string}
     * @memberof CommonGetAutocompleteV1ResponseMPayload
     */
    group: string;
    /**
     * The Unique ID of the element
     * @type {string}
     * @memberof CommonGetAutocompleteV1ResponseMPayload
     */
    id: string;
    /**
     * The Description of the element
     * @type {string}
     * @memberof CommonGetAutocompleteV1ResponseMPayload
     */
    option: string;
}
/**
 * All API response will inherit this based Response
 * @export
 * @interface CommonResponse
 */
export interface CommonResponse {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof CommonResponse
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof CommonResponse
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Generic Error Message
 * @export
 * @interface CommonResponseError
 */
export interface CommonResponseError {
    /**
     * More detail about the error
     * @type {string}
     * @memberof CommonResponseError
     */
    sErrorMessage: string;
}
/**
 * This is a generic debug object that is returned by all API requests
 * @export
 * @interface CommonResponseObjDebug
 */
export interface CommonResponseObjDebug {
    /**
     * The peak memory allocated during the API request execution. Formatted as a human readable string
     * @type {string}
     * @memberof CommonResponseObjDebug
     */
    sMemoryUsage: string;
    /**
     * The total server execution time of the API request execution. Formatted as a human readable string
     * @type {string}
     * @memberof CommonResponseObjDebug
     */
    sRunTime: string;
    /**
     * The number of SQL SELECT queries that were sent to the database server during the API request execution
     * @type {number}
     * @memberof CommonResponseObjDebug
     */
    iSQLSelects: number;
    /**
     * The number of SQL INSERT/UPDATE/DELETE queries that were sent to the database server during the API request execution
     * @type {number}
     * @memberof CommonResponseObjDebug
     */
    iSQLQueries: number;
    /**
     * An array of the SQL Queries that were executed during the API request execution
     * @type {Array<CommonResponseObjSQLQuery>}
     * @memberof CommonResponseObjDebug
     */
    a_objSQLQuery: Array<CommonResponseObjSQLQuery>;
}
/**
 * This is a debug object containing debugging information on the actual function
 * @export
 * @interface CommonResponseObjDebugPayload
 */
export interface CommonResponseObjDebugPayload {
    /**
     * The minimum version of the function that can be called
     * @type {number}
     * @memberof CommonResponseObjDebugPayload
     */
    iVersionMin: number;
    /**
     * The maximum version of the function that can be called
     * @type {number}
     * @memberof CommonResponseObjDebugPayload
     */
    iVersionMax: number;
    /**
     * An array of permissions required to access this function.  If the value \"0\" is present in the array, anyone can call this function.  You must have one of the permission to access the function. You don\'t need to have all of them.
     * @type {Array<number>}
     * @memberof CommonResponseObjDebugPayload
     */
    a_RequiredPermissions: Array<number>;
}
/**
 * Definition of objSQLQuery Object
 * @export
 * @interface CommonResponseObjSQLQuery
 */
export interface CommonResponseObjSQLQuery {
    /**
     * The SQL Query
     * @type {string}
     * @memberof CommonResponseObjSQLQuery
     */
    sQuery: string;
    /**
     * Execution time of the SQL Query in seconds
     * @type {number}
     * @memberof CommonResponseObjSQLQuery
     */
    fDuration: number;
}
/**
 * This is the base Webhook object
 * @export
 * @interface CommonWebhook
 */
export interface CommonWebhook {
    /**
     * 
     * @type {WebhookResponse}
     * @memberof CommonWebhook
     */
    objWebhook: WebhookResponse;
    /**
     * An array containing details of previous attempts that were made to deliver the message. The array is empty if it\'s the first attempt.
     * @type {Array<AttemptResponse>}
     * @memberof CommonWebhook
     */
    a_objAttempt: Array<AttemptResponse>;
}
/**
 * A Contact Object
 * @export
 * @interface ContactRequest
 */
export interface ContactRequest {
    /**
     * The unique ID of the Contacttitle.  Valid values:  |Value|Description| |-|-| |1|Ms.| |2|Mr.| |4|(Blank)| |5|Me (For Notaries)|
     * @type {number}
     * @memberof ContactRequest
     */
    fkiContacttitleID: number;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof ContactRequest
     */
    fkiLanguageID: number;
    /**
     * The First name of the contact
     * @type {string}
     * @memberof ContactRequest
     */
    sContactFirstname: string;
    /**
     * The Last name of the contact
     * @type {string}
     * @memberof ContactRequest
     */
    sContactLastname: string;
    /**
     * The Company name of the contact
     * @type {string}
     * @memberof ContactRequest
     */
    sContactCompany: string;
    /**
     * The Birth Date of the contact
     * @type {string}
     * @memberof ContactRequest
     */
    dtContactBirthdate?: string;
}
/**
 * A Contact Object and children to create a complete structure
 * @export
 * @interface ContactRequestCompound
 */
export interface ContactRequestCompound {
    /**
     * 
     * @type {ContactinformationsRequestCompound}
     * @memberof ContactRequestCompound
     */
    objContactinformations: ContactinformationsRequestCompound;
    /**
     * The unique ID of the Contacttitle.  Valid values:  |Value|Description| |-|-| |1|Ms.| |2|Mr.| |4|(Blank)| |5|Me (For Notaries)|
     * @type {number}
     * @memberof ContactRequestCompound
     */
    fkiContacttitleID: number;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof ContactRequestCompound
     */
    fkiLanguageID: number;
    /**
     * The First name of the contact
     * @type {string}
     * @memberof ContactRequestCompound
     */
    sContactFirstname: string;
    /**
     * The Last name of the contact
     * @type {string}
     * @memberof ContactRequestCompound
     */
    sContactLastname: string;
    /**
     * The Company name of the contact
     * @type {string}
     * @memberof ContactRequestCompound
     */
    sContactCompany: string;
    /**
     * The Birth Date of the contact
     * @type {string}
     * @memberof ContactRequestCompound
     */
    dtContactBirthdate?: string;
}
/**
 * 
 * @export
 * @interface ContactRequestCompoundAllOf
 */
export interface ContactRequestCompoundAllOf {
    /**
     * 
     * @type {ContactinformationsRequestCompound}
     * @memberof ContactRequestCompoundAllOf
     */
    objContactinformations: ContactinformationsRequestCompound;
}
/**
 * A Contactinformations Object
 * @export
 * @interface ContactinformationsRequest
 */
export interface ContactinformationsRequest {
    /**
     * The index in the a_objAddress array (zero based index) representing the Address object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequest
     */
    iAddressDefault: number;
    /**
     * The index in the a_objPhone array (zero based index) representing the Phone object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequest
     */
    iPhoneDefault: number;
    /**
     * The index in the a_objEmail array (zero based index) representing the Email object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequest
     */
    iEmailDefault: number;
    /**
     * The index in the a_objWebsite array (zero based index) representing the Website object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequest
     */
    iWebsiteDefault: number;
}
/**
 * A Contactinformations Object and children to create a complete structure
 * @export
 * @interface ContactinformationsRequestCompound
 */
export interface ContactinformationsRequestCompound {
    /**
     * 
     * @type {Array<AddressRequest>}
     * @memberof ContactinformationsRequestCompound
     */
    a_objAddress: Array<AddressRequest>;
    /**
     * 
     * @type {Array<PhoneRequest>}
     * @memberof ContactinformationsRequestCompound
     */
    a_objPhone: Array<PhoneRequest>;
    /**
     * 
     * @type {Array<EmailRequest>}
     * @memberof ContactinformationsRequestCompound
     */
    a_objEmail: Array<EmailRequest>;
    /**
     * 
     * @type {Array<WebsiteRequest>}
     * @memberof ContactinformationsRequestCompound
     */
    a_objWebsite: Array<WebsiteRequest>;
    /**
     * The index in the a_objAddress array (zero based index) representing the Address object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequestCompound
     */
    iAddressDefault: number;
    /**
     * The index in the a_objPhone array (zero based index) representing the Phone object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequestCompound
     */
    iPhoneDefault: number;
    /**
     * The index in the a_objEmail array (zero based index) representing the Email object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequestCompound
     */
    iEmailDefault: number;
    /**
     * The index in the a_objWebsite array (zero based index) representing the Website object that should become the default one.  You can leave the value to 0 if the array is empty.
     * @type {number}
     * @memberof ContactinformationsRequestCompound
     */
    iWebsiteDefault: number;
}
/**
 * A Contact Object
 * @export
 * @interface EmailRequest
 */
export interface EmailRequest {
    /**
     * The unique ID of the Emailtype.  Valid values:  |Value|Description| |-|-| |1|Office| |2|Home|
     * @type {number}
     * @memberof EmailRequest
     */
    fkiEmailtypeID: number;
    /**
     * The email address.
     * @type {string}
     * @memberof EmailRequest
     */
    sEmailAddress: string;
}
/**
 * Request for the /1/object/ezsigndocument/{pkiEzsigndocumentID}/applyezsigntemplate API Request
 * @export
 * @interface EzsigndocumentApplyEzsigntemplateV1Request
 */
export interface EzsigndocumentApplyEzsigntemplateV1Request {
    /**
     * The unique ID of the Ezsigndocument
     * @type {number}
     * @memberof EzsigndocumentApplyEzsigntemplateV1Request
     */
    fkiEzsigntemplateID: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EzsigndocumentApplyEzsigntemplateV1Request
     */
    a_sEzsigntemplatesigner: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EzsigndocumentApplyEzsigntemplateV1Request
     */
    a_pkiEzsignfoldersignerassociationID: Array<number>;
}
/**
 * Response for the /1/object/ezsigndocument/{pkiEzsigndocument}/applyEzsigntemplate API Request
 * @export
 * @interface EzsigndocumentApplyEzsigntemplateV1Response
 */
export interface EzsigndocumentApplyEzsigntemplateV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentApplyEzsigntemplateV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentApplyEzsigntemplateV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsigndocument/createObject API Request
 * @export
 * @interface EzsigndocumentCreateObjectV1Request
 */
export interface EzsigndocumentCreateObjectV1Request {
    /**
     * 
     * @type {EzsigndocumentRequest}
     * @memberof EzsigndocumentCreateObjectV1Request
     */
    objEzsigndocument?: EzsigndocumentRequest;
    /**
     * 
     * @type {EzsigndocumentRequestCompound}
     * @memberof EzsigndocumentCreateObjectV1Request
     */
    objEzsigndocumentCompound?: EzsigndocumentRequestCompound;
}
/**
 * Response for the /1/object/ezsigndocument/createObject API Request
 * @export
 * @interface EzsigndocumentCreateObjectV1Response
 */
export interface EzsigndocumentCreateObjectV1Response {
    /**
     * 
     * @type {EzsigndocumentCreateObjectV1ResponseMPayload}
     * @memberof EzsigndocumentCreateObjectV1Response
     */
    mPayload: EzsigndocumentCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsigndocument/createObject API Request
 * @export
 * @interface EzsigndocumentCreateObjectV1ResponseMPayload
 */
export interface EzsigndocumentCreateObjectV1ResponseMPayload {
    /**
     * An array of unique IDs representing the object that were requested to be created.  They are returned in the same order as the array containing the objects to be created that was sent in the request.
     * @type {Array<number>}
     * @memberof EzsigndocumentCreateObjectV1ResponseMPayload
     */
    a_pkiEzsigndocumentID: Array<number>;
}
/**
 * Response for the /1/object/ezsigndocument/deleteObject API Request
 * @export
 * @interface EzsigndocumentDeleteObjectV1Response
 */
export interface EzsigndocumentDeleteObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentDeleteObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentDeleteObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsigndocument/editObject API Request
 * @export
 * @interface EzsigndocumentEditObjectV1Request
 */
export interface EzsigndocumentEditObjectV1Request {
    /**
     * 
     * @type {EzsigndocumentRequest}
     * @memberof EzsigndocumentEditObjectV1Request
     */
    objEzsigndocument?: EzsigndocumentRequest;
}
/**
 * Response for the /1/object/ezsigndocument/editObject API Request
 * @export
 * @interface EzsigndocumentEditObjectV1Response
 */
export interface EzsigndocumentEditObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentEditObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentEditObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Response for the /1/object/ezsigndocument/{pkiEzsigndocument}/getDownloadUrl API Request
 * @export
 * @interface EzsigndocumentGetDownloadUrlV1Response
 */
export interface EzsigndocumentGetDownloadUrlV1Response {
    /**
     * 
     * @type {EzsigndocumentGetDownloadUrlV1ResponseMPayload}
     * @memberof EzsigndocumentGetDownloadUrlV1Response
     */
    mPayload: EzsigndocumentGetDownloadUrlV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentGetDownloadUrlV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentGetDownloadUrlV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsigndocument/{pkiEzsigndocument}/getDownloadUrl API Request
 * @export
 * @interface EzsigndocumentGetDownloadUrlV1ResponseMPayload
 */
export interface EzsigndocumentGetDownloadUrlV1ResponseMPayload {
    /**
     * The Url to the requested document.  Url will expire after 5 minutes.
     * @type {string}
     * @memberof EzsigndocumentGetDownloadUrlV1ResponseMPayload
     */
    sDownloadUrl: string;
}
/**
 * Response for the /1/object/ezsigndocument/getDownloadUrl API Request
 * @export
 * @interface EzsigndocumentGetObjectV1Response
 */
export interface EzsigndocumentGetObjectV1Response {
    /**
     * 
     * @type {EzsigndocumentGetObjectV1ResponseMPayload}
     * @memberof EzsigndocumentGetObjectV1Response
     */
    mPayload: EzsigndocumentGetObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsigndocumentGetObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsigndocumentGetObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsigndocument/getObject API Request
 * @export
 * @interface EzsigndocumentGetObjectV1ResponseMPayload
 */
export interface EzsigndocumentGetObjectV1ResponseMPayload {
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    fkiEzsignfolderID: number;
    /**
     * The maximum date and time at which the document can be signed.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    sEzsigndocumentName: string;
    /**
     * The unique ID of the Ezsigntemplate
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    pkiEzsigndocumentID: number;
    /**
     * 
     * @type {FieldEEzsigndocumentStep}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    eEzsigndocumentStep: FieldEEzsigndocumentStep;
    /**
     * The date and time when the Ezsigndocument was first sent.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    dtEzsigndocumentFirstsend: string;
    /**
     * The date and time when the Ezsigndocument was sent the last time.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    dtEzsigndocumentLastsend: string;
    /**
     * The order in which the Ezsigndocument will be presented to the signatory in the Ezsignfolder.
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    iEzsigndocumentOrder: number;
    /**
     * The number of pages in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    iEzsigndocumentPagetotal: number;
    /**
     * The number of signatures that were signed in the document.
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    iEzsigndocumentSignaturesigned: number;
    /**
     * The number of total signatures that were requested in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    iEzsigndocumentSignaturetotal: number;
    /**
     * MD5 Hash of the initial PDF Document before signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    sEzsigndocumentMD5initial: string;
    /**
     * MD5 Hash of the final PDF Document after all signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    sEzsigndocumentMD5signed: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsigndocumentGetObjectV1ResponseMPayload
     */
    objAudit: CommonAudit;
}
/**
 * An Ezsigndocument Object
 * @export
 * @interface EzsigndocumentRequest
 */
export interface EzsigndocumentRequest {
    /**
     * Indicates where to look for the document binary content.
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    eEzsigndocumentSource: EzsigndocumentRequestEEzsigndocumentSourceEnum;
    /**
     * Indicates the format of the document.
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    eEzsigndocumentFormat: EzsigndocumentRequestEEzsigndocumentFormatEnum;
    /**
     * The Base64 encoded binary content of the document.  This field is Required when eEzsigndocumentSource = Base64.
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    sEzsigndocumentBase64?: string;
    /**
     * A reference to a valid Ezsignfolder.  That value is returned after a successful Ezsignfolder Creation.
     * @type {number}
     * @memberof EzsigndocumentRequest
     */
    fkiEzsignfolderID: number;
    /**
     * Represent a Date Time. The timezone is the one configured in the User\'s profile.
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentRequest
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentRequest
     */
    sEzsigndocumentName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsigndocumentRequestEEzsigndocumentSourceEnum {
    Base64 = 'Base64'
}
/**
    * @export
    * @enum {string}
    */
export enum EzsigndocumentRequestEEzsigndocumentFormatEnum {
    Pdf = 'Pdf'
}

/**
 * An Ezsigndocument Object and children to create a complete structure
 * @export
 * @interface EzsigndocumentRequestCompound
 */
export interface EzsigndocumentRequestCompound {
    /**
     * Indicates where to look for the document binary content.
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    eEzsigndocumentSource: EzsigndocumentRequestCompoundEEzsigndocumentSourceEnum;
    /**
     * Indicates the format of the document.
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    eEzsigndocumentFormat: EzsigndocumentRequestCompoundEEzsigndocumentFormatEnum;
    /**
     * The Base64 encoded binary content of the document.  This field is Required when eEzsigndocumentSource = Base64.
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    sEzsigndocumentBase64?: string;
    /**
     * A reference to a valid Ezsignfolder.  That value is returned after a successful Ezsignfolder Creation.
     * @type {number}
     * @memberof EzsigndocumentRequestCompound
     */
    fkiEzsignfolderID: number;
    /**
     * Represent a Date Time. The timezone is the one configured in the User\'s profile.
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentRequestCompound
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentRequestCompound
     */
    sEzsigndocumentName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsigndocumentRequestCompoundEEzsigndocumentSourceEnum {
    Base64 = 'Base64'
}
/**
    * @export
    * @enum {string}
    */
export enum EzsigndocumentRequestCompoundEEzsigndocumentFormatEnum {
    Pdf = 'Pdf'
}

/**
 * An Ezsigndocument Object
 * @export
 * @interface EzsigndocumentResponse
 */
export interface EzsigndocumentResponse {
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    fkiEzsignfolderID: number;
    /**
     * The maximum date and time at which the document can be signed.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    sEzsigndocumentName: string;
    /**
     * The unique ID of the Ezsigntemplate
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    pkiEzsigndocumentID: number;
    /**
     * 
     * @type {FieldEEzsigndocumentStep}
     * @memberof EzsigndocumentResponse
     */
    eEzsigndocumentStep: FieldEEzsigndocumentStep;
    /**
     * The date and time when the Ezsigndocument was first sent.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    dtEzsigndocumentFirstsend: string;
    /**
     * The date and time when the Ezsigndocument was sent the last time.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    dtEzsigndocumentLastsend: string;
    /**
     * The order in which the Ezsigndocument will be presented to the signatory in the Ezsignfolder.
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    iEzsigndocumentOrder: number;
    /**
     * The number of pages in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    iEzsigndocumentPagetotal: number;
    /**
     * The number of signatures that were signed in the document.
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    iEzsigndocumentSignaturesigned: number;
    /**
     * The number of total signatures that were requested in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponse
     */
    iEzsigndocumentSignaturetotal: number;
    /**
     * MD5 Hash of the initial PDF Document before signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    sEzsigndocumentMD5initial: string;
    /**
     * MD5 Hash of the final PDF Document after all signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponse
     */
    sEzsigndocumentMD5signed: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsigndocumentResponse
     */
    objAudit: CommonAudit;
}
/**
 * 
 * @export
 * @interface EzsigndocumentResponseAllOf
 */
export interface EzsigndocumentResponseAllOf {
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    fkiEzsignfolderID: number;
    /**
     * The maximum date and time at which the document can be signed.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    sEzsigndocumentName: string;
    /**
     * The unique ID of the Ezsigntemplate
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    pkiEzsigndocumentID: number;
    /**
     * 
     * @type {FieldEEzsigndocumentStep}
     * @memberof EzsigndocumentResponseAllOf
     */
    eEzsigndocumentStep: FieldEEzsigndocumentStep;
    /**
     * The date and time when the Ezsigndocument was first sent.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    dtEzsigndocumentFirstsend: string;
    /**
     * The date and time when the Ezsigndocument was sent the last time.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    dtEzsigndocumentLastsend: string;
    /**
     * The order in which the Ezsigndocument will be presented to the signatory in the Ezsignfolder.
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    iEzsigndocumentOrder: number;
    /**
     * The number of pages in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    iEzsigndocumentPagetotal: number;
    /**
     * The number of signatures that were signed in the document.
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    iEzsigndocumentSignaturesigned: number;
    /**
     * The number of total signatures that were requested in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponseAllOf
     */
    iEzsigndocumentSignaturetotal: number;
    /**
     * MD5 Hash of the initial PDF Document before signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    sEzsigndocumentMD5initial: string;
    /**
     * MD5 Hash of the final PDF Document after all signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponseAllOf
     */
    sEzsigndocumentMD5signed: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsigndocumentResponseAllOf
     */
    objAudit: CommonAudit;
}
/**
 * An Ezsigndocument Object and children to create a complete structure
 * @export
 * @interface EzsigndocumentResponseCompound
 */
export interface EzsigndocumentResponseCompound {
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    fkiEzsignfolderID: number;
    /**
     * The maximum date and time at which the document can be signed.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    dtEzsigndocumentDuedate: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    fkiLanguageID: number;
    /**
     * The actual file name that will be used when downloading or attaching to an email.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    sEzsigndocumentFilename: string;
    /**
     * The name of the document that will be presented to Ezsignfoldersignerassociations
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    sEzsigndocumentName: string;
    /**
     * The unique ID of the Ezsigntemplate
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    pkiEzsigndocumentID: number;
    /**
     * 
     * @type {FieldEEzsigndocumentStep}
     * @memberof EzsigndocumentResponseCompound
     */
    eEzsigndocumentStep: FieldEEzsigndocumentStep;
    /**
     * The date and time when the Ezsigndocument was first sent.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    dtEzsigndocumentFirstsend: string;
    /**
     * The date and time when the Ezsigndocument was sent the last time.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    dtEzsigndocumentLastsend: string;
    /**
     * The order in which the Ezsigndocument will be presented to the signatory in the Ezsignfolder.
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    iEzsigndocumentOrder: number;
    /**
     * The number of pages in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    iEzsigndocumentPagetotal: number;
    /**
     * The number of signatures that were signed in the document.
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    iEzsigndocumentSignaturesigned: number;
    /**
     * The number of total signatures that were requested in the Ezsigndocument.
     * @type {number}
     * @memberof EzsigndocumentResponseCompound
     */
    iEzsigndocumentSignaturetotal: number;
    /**
     * MD5 Hash of the initial PDF Document before signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    sEzsigndocumentMD5initial: string;
    /**
     * MD5 Hash of the final PDF Document after all signatures were applied to it.
     * @type {string}
     * @memberof EzsigndocumentResponseCompound
     */
    sEzsigndocumentMD5signed: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsigndocumentResponseCompound
     */
    objAudit: CommonAudit;
}
/**
 * Request for the /1/object/ezsignfolder/createObject API Request
 * @export
 * @interface EzsignfolderCreateObjectV1Request
 */
export interface EzsignfolderCreateObjectV1Request {
    /**
     * 
     * @type {EzsignfolderRequest}
     * @memberof EzsignfolderCreateObjectV1Request
     */
    objEzsignfolder?: EzsignfolderRequest;
    /**
     * 
     * @type {EzsignfolderRequestCompound}
     * @memberof EzsignfolderCreateObjectV1Request
     */
    objEzsignfolderCompound?: EzsignfolderRequestCompound;
}
/**
 * Response for the /1/object/ezsignfolder/createObject API Request
 * @export
 * @interface EzsignfolderCreateObjectV1Response
 */
export interface EzsignfolderCreateObjectV1Response {
    /**
     * 
     * @type {EzsignfolderCreateObjectV1ResponseMPayload}
     * @memberof EzsignfolderCreateObjectV1Response
     */
    mPayload: EzsignfolderCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfolderCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfolderCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsignfolder/createObject API Request
 * @export
 * @interface EzsignfolderCreateObjectV1ResponseMPayload
 */
export interface EzsignfolderCreateObjectV1ResponseMPayload {
    /**
     * An array of unique IDs representing the object that were requested to be created.  They are returned in the same order as the array containing the objects to be created that was sent in the request.
     * @type {Array<number>}
     * @memberof EzsignfolderCreateObjectV1ResponseMPayload
     */
    a_pkiEzsignfolderID: Array<number>;
}
/**
 * Response for the /1/object/ezsignfolder/deleteObject API Request
 * @export
 * @interface EzsignfolderDeleteObjectV1Response
 */
export interface EzsignfolderDeleteObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfolderDeleteObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfolderDeleteObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsignfolder/editObject API Request
 * @export
 * @interface EzsignfolderEditObjectV1Request
 */
export interface EzsignfolderEditObjectV1Request {
    /**
     * 
     * @type {EzsignfolderRequest}
     * @memberof EzsignfolderEditObjectV1Request
     */
    objEzsignfolder?: EzsignfolderRequest;
}
/**
 * Response for the /1/object/ezsignfolder/editObject API Request
 * @export
 * @interface EzsignfolderEditObjectV1Response
 */
export interface EzsignfolderEditObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfolderEditObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfolderEditObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Response for the /1/object/ezsignfolder/getObject API Request
 * @export
 * @interface EzsignfolderGetObjectV1Response
 */
export interface EzsignfolderGetObjectV1Response {
    /**
     * 
     * @type {EzsignfolderGetObjectV1ResponseMPayload}
     * @memberof EzsignfolderGetObjectV1Response
     */
    mPayload: EzsignfolderGetObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfolderGetObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfolderGetObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsignfolder/getObject API Request
 * @export
 * @interface EzsignfolderGetObjectV1ResponseMPayload
 */
export interface EzsignfolderGetObjectV1ResponseMPayload {
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    pkiEzsignfolderID: number;
    /**
     * The date and time at which the Ezsign folder was sent the last time.
     * @type {string}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    dtEzsignfolderSentdate: string;
    /**
     * 
     * @type {FieldEEzsignfolderStep}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    eEzsignfolderStep: FieldEEzsignfolderStep;
    /**
     * The date and time at which the folder was closed. Either by applying the last signature or by completing it prematurely.
     * @type {string}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    dtEzsignfolderClose: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsignfolderGetObjectV1ResponseMPayload
     */
    objAudit: CommonAudit;
}
/**
 * An Ezsignfolder Object
 * @export
 * @interface EzsignfolderRequest
 */
export interface EzsignfolderRequest {
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderRequest
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderRequest
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderRequest
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderRequest
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderRequest
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
}
/**
 * An Ezsignfolder Object and children to create a complete structure
 * @export
 * @interface EzsignfolderRequestCompound
 */
export interface EzsignfolderRequestCompound {
    /**
     * An array of signers that will be invited to sign the Ezsigndocuments
     * @type {Array<EzsignfoldersignerassociationRequest>}
     * @memberof EzsignfolderRequestCompound
     */
    a_Ezsignfoldersignerassociation: Array<EzsignfoldersignerassociationRequest>;
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderRequestCompound
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderRequestCompound
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderRequestCompound
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderRequestCompound
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderRequestCompound
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
}
/**
 * An Ezsignfolder Object
 * @export
 * @interface EzsignfolderResponse
 */
export interface EzsignfolderResponse {
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderResponse
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderResponse
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderResponse
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderResponse
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderResponse
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsignfolderResponse
     */
    pkiEzsignfolderID: number;
    /**
     * The date and time at which the Ezsign folder was sent the last time.
     * @type {string}
     * @memberof EzsignfolderResponse
     */
    dtEzsignfolderSentdate: string;
    /**
     * 
     * @type {FieldEEzsignfolderStep}
     * @memberof EzsignfolderResponse
     */
    eEzsignfolderStep: FieldEEzsignfolderStep;
    /**
     * The date and time at which the folder was closed. Either by applying the last signature or by completing it prematurely.
     * @type {string}
     * @memberof EzsignfolderResponse
     */
    dtEzsignfolderClose: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsignfolderResponse
     */
    objAudit: CommonAudit;
}
/**
 * 
 * @export
 * @interface EzsignfolderResponseAllOf
 */
export interface EzsignfolderResponseAllOf {
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderResponseAllOf
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderResponseAllOf
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderResponseAllOf
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderResponseAllOf
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderResponseAllOf
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsignfolderResponseAllOf
     */
    pkiEzsignfolderID: number;
    /**
     * The date and time at which the Ezsign folder was sent the last time.
     * @type {string}
     * @memberof EzsignfolderResponseAllOf
     */
    dtEzsignfolderSentdate: string;
    /**
     * 
     * @type {FieldEEzsignfolderStep}
     * @memberof EzsignfolderResponseAllOf
     */
    eEzsignfolderStep: FieldEEzsignfolderStep;
    /**
     * The date and time at which the folder was closed. Either by applying the last signature or by completing it prematurely.
     * @type {string}
     * @memberof EzsignfolderResponseAllOf
     */
    dtEzsignfolderClose: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsignfolderResponseAllOf
     */
    objAudit: CommonAudit;
}
/**
 * An Ezsignfolder Object and children to create a complete structure
 * @export
 * @interface EzsignfolderResponseCompound
 */
export interface EzsignfolderResponseCompound {
    /**
     * The unique ID of the Ezsignfoldertype.    This value can be queried by the API and is also visible in the admin interface.    There are two types of Ezsignfoldertype. **User** and **Shared**. **User** can only be seen by the user who created the folder or its assistants. Access to **Shared** folders are configurable for access and email delivery. You should typically choose a **Shared** type here.
     * @type {number}
     * @memberof EzsignfolderResponseCompound
     */
    fkiEzsignfoldertypeID: number;
    /**
     * The unique ID of the Ezsigntsarequirement.  Determine if a Time Stamping Authority should add a timestamp on each of the signature. Valid values:  |Value|Description| |-|-| |1|No. TSA Timestamping will requested. This will make all signatures a lot faster since no round-trip to the TSA server will be required. Timestamping will be made using eZsign server\'s time.| |2|Best effort. Timestamping from a Time Stamping Authority will be requested but is not mandatory. In the very improbable case it cannot be completed, the timestamping will be made using eZsign server\'s time. **Additional fee applies**| |3|Mandatory. Timestamping from a Time Stamping Authority will be requested and is mandatory. In the very improbable case it cannot be completed, the signature will fail and the user will be asked to retry. **Additional fee applies**|
     * @type {number}
     * @memberof EzsignfolderResponseCompound
     */
    fkiEzsigntsarequirementID: number;
    /**
     * The description of the Ezsign Folder
     * @type {string}
     * @memberof EzsignfolderResponseCompound
     */
    sEzsignfolderDescription: string;
    /**
     * Somes extra notes about the eZsign Folder
     * @type {string}
     * @memberof EzsignfolderResponseCompound
     */
    tEzsignfolderNote: string;
    /**
     * 
     * @type {FieldEEzsignfolderSendreminderfrequency}
     * @memberof EzsignfolderResponseCompound
     */
    eEzsignfolderSendreminderfrequency: FieldEEzsignfolderSendreminderfrequency;
    /**
     * The unique ID of the Ezsignfolder
     * @type {number}
     * @memberof EzsignfolderResponseCompound
     */
    pkiEzsignfolderID: number;
    /**
     * The date and time at which the Ezsign folder was sent the last time.
     * @type {string}
     * @memberof EzsignfolderResponseCompound
     */
    dtEzsignfolderSentdate: string;
    /**
     * 
     * @type {FieldEEzsignfolderStep}
     * @memberof EzsignfolderResponseCompound
     */
    eEzsignfolderStep: FieldEEzsignfolderStep;
    /**
     * The date and time at which the folder was closed. Either by applying the last signature or by completing it prematurely.
     * @type {string}
     * @memberof EzsignfolderResponseCompound
     */
    dtEzsignfolderClose: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof EzsignfolderResponseCompound
     */
    objAudit: CommonAudit;
}
/**
 * Request for the /1/object/ezsignfolder/{pkiEzsignfolderID}/send API Request
 * @export
 * @interface EzsignfolderSendV1Request
 */
export interface EzsignfolderSendV1Request {
    /**
     * A custom text message that will be added to the email sent to signatories inviting them to sign.  You can send an empty string and only the generic message will be sent.
     * @type {string}
     * @memberof EzsignfolderSendV1Request
     */
    tExtraMessage: string;
}
/**
 * Response for the /1/object/ezsignfolder/{pkiEzsignfolderID}/send API Request
 * @export
 * @interface EzsignfolderSendV1Response
 */
export interface EzsignfolderSendV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfolderSendV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfolderSendV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsignfoldersignerassociation/createObject API Request
 * @export
 * @interface EzsignfoldersignerassociationCreateObjectV1Request
 */
export interface EzsignfoldersignerassociationCreateObjectV1Request {
    /**
     * 
     * @type {EzsignfoldersignerassociationRequest}
     * @memberof EzsignfoldersignerassociationCreateObjectV1Request
     */
    objEzsignfoldersignerassociation?: EzsignfoldersignerassociationRequest;
    /**
     * 
     * @type {EzsignfoldersignerassociationRequestCompound}
     * @memberof EzsignfoldersignerassociationCreateObjectV1Request
     */
    objEzsignfoldersignerassociationCompound?: EzsignfoldersignerassociationRequestCompound;
}
/**
 * Response for the /1/object/ezsignfoldersignerassociation/createObject API Request
 * @export
 * @interface EzsignfoldersignerassociationCreateObjectV1Response
 */
export interface EzsignfoldersignerassociationCreateObjectV1Response {
    /**
     * 
     * @type {EzsignfoldersignerassociationCreateObjectV1ResponseMPayload}
     * @memberof EzsignfoldersignerassociationCreateObjectV1Response
     */
    mPayload: EzsignfoldersignerassociationCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfoldersignerassociationCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfoldersignerassociationCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsignfoldersignerassociation/createObject API Request
 * @export
 * @interface EzsignfoldersignerassociationCreateObjectV1ResponseMPayload
 */
export interface EzsignfoldersignerassociationCreateObjectV1ResponseMPayload {
    /**
     * An array of unique IDs representing the object that were requested to be created.  They are returned in the same order as the array containing the objects to be created that was sent in the request.
     * @type {Array<number>}
     * @memberof EzsignfoldersignerassociationCreateObjectV1ResponseMPayload
     */
    a_pkiEzsignfoldersignerassociationID: Array<number>;
}
/**
 * Response for the /1/object/ezsignfoldersignerassociation/deleteObject API Request
 * @export
 * @interface EzsignfoldersignerassociationDeleteObjectV1Response
 */
export interface EzsignfoldersignerassociationDeleteObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfoldersignerassociationDeleteObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfoldersignerassociationDeleteObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsignfoldersignerassociation/editObject API Request
 * @export
 * @interface EzsignfoldersignerassociationEditObjectV1Request
 */
export interface EzsignfoldersignerassociationEditObjectV1Request {
    /**
     * 
     * @type {EzsignfoldersignerassociationRequest}
     * @memberof EzsignfoldersignerassociationEditObjectV1Request
     */
    objEzsignfoldersignerassociation?: EzsignfoldersignerassociationRequest;
}
/**
 * Response for the /1/object/ezsignfoldersignerassociation/editObject API Request
 * @export
 * @interface EzsignfoldersignerassociationEditObjectV1Response
 */
export interface EzsignfoldersignerassociationEditObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfoldersignerassociationEditObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfoldersignerassociationEditObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Response for the /1/object/ezsignfoldersignerassociation/getInPersonLoginUrl API Request
 * @export
 * @interface EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
 */
export interface EzsignfoldersignerassociationGetInPersonLoginUrlV1Response {
    /**
     * 
     * @type {EzsignfoldersignerassociationGetInPersonLoginUrlV1ResponseMPayload}
     * @memberof EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
     */
    mPayload: EzsignfoldersignerassociationGetInPersonLoginUrlV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsignfoldersignerassociation/getInPersonLoginUrl API Request
 * @export
 * @interface EzsignfoldersignerassociationGetInPersonLoginUrlV1ResponseMPayload
 */
export interface EzsignfoldersignerassociationGetInPersonLoginUrlV1ResponseMPayload {
    /**
     * The Url to login to the signing application.    Url will expire after 30 minutes.  
     * @type {string}
     * @memberof EzsignfoldersignerassociationGetInPersonLoginUrlV1ResponseMPayload
     */
    sLoginUrl: string;
}
/**
 * Response for the /1/object/ezsignfoldersignerassociation/getObject API Request
 * @export
 * @interface EzsignfoldersignerassociationGetObjectV1Response
 */
export interface EzsignfoldersignerassociationGetObjectV1Response {
    /**
     * Payload for the /1/object/ezsignfoldersignerassociation/getObject API Request
     * @type {object}
     * @memberof EzsignfoldersignerassociationGetObjectV1Response
     */
    mPayload: object;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignfoldersignerassociationGetObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignfoldersignerassociationGetObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * An Ezsignfoldersignerassociation Object
 * @export
 * @interface EzsignfoldersignerassociationRequest
 */
export interface EzsignfoldersignerassociationRequest {
    /**
     * A reference to a valid User.  This is only used if the signatory will be a user from the system.
     * @type {number}
     * @memberof EzsignfoldersignerassociationRequest
     */
    fkiUserID?: number;
    /**
     * A reference to a valid Ezsignfolder.  That value is returned after a successful Ezsignfolder Creation.
     * @type {number}
     * @memberof EzsignfoldersignerassociationRequest
     */
    fkiEzsignfolderID: number;
}
/**
 * An Ezsignfoldersignerassociation Object and children to create a complete structure
 * @export
 * @interface EzsignfoldersignerassociationRequestCompound
 */
export interface EzsignfoldersignerassociationRequestCompound {
    /**
     * 
     * @type {EzsignsignerRequestCompound}
     * @memberof EzsignfoldersignerassociationRequestCompound
     */
    objEzsignsigner?: EzsignsignerRequestCompound;
    /**
     * A reference to a valid User.  This is only used if the signatory will be a user from the system.
     * @type {number}
     * @memberof EzsignfoldersignerassociationRequestCompound
     */
    fkiUserID?: number;
    /**
     * A reference to a valid Ezsignfolder.  That value is returned after a successful Ezsignfolder Creation.
     * @type {number}
     * @memberof EzsignfoldersignerassociationRequestCompound
     */
    fkiEzsignfolderID: number;
}
/**
 * Request for the /1/object/ezsignsignature/createObject API Request
 * @export
 * @interface EzsignsignatureCreateObjectV1Request
 */
export interface EzsignsignatureCreateObjectV1Request {
    /**
     * 
     * @type {EzsignsignatureRequest}
     * @memberof EzsignsignatureCreateObjectV1Request
     */
    objEzsignsignature?: EzsignsignatureRequest;
    /**
     * 
     * @type {EzsignsignatureRequestCompound}
     * @memberof EzsignsignatureCreateObjectV1Request
     */
    objEzsignsignatureCompound?: EzsignsignatureRequestCompound;
}
/**
 * Response for the /1/object/ezsignsignature/createObject API Request
 * @export
 * @interface EzsignsignatureCreateObjectV1Response
 */
export interface EzsignsignatureCreateObjectV1Response {
    /**
     * 
     * @type {EzsignsignatureCreateObjectV1ResponseMPayload}
     * @memberof EzsignsignatureCreateObjectV1Response
     */
    mPayload: EzsignsignatureCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignsignatureCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignsignatureCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/ezsignsignature/createObject API Request
 * @export
 * @interface EzsignsignatureCreateObjectV1ResponseMPayload
 */
export interface EzsignsignatureCreateObjectV1ResponseMPayload {
    /**
     * An array of unique IDs representing the object that were requested to be created.  They are returned in the same order as the array containing the objects to be created that was sent in the request.
     * @type {Array<number>}
     * @memberof EzsignsignatureCreateObjectV1ResponseMPayload
     */
    a_pkiEzsignsignatureID: Array<number>;
}
/**
 * Response for the /1/object/ezsignsignature/deleteObject API Request
 * @export
 * @interface EzsignsignatureDeleteObjectV1Response
 */
export interface EzsignsignatureDeleteObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignsignatureDeleteObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignsignatureDeleteObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Request for the /1/object/ezsignsignature/editObject API Request
 * @export
 * @interface EzsignsignatureEditObjectV1Request
 */
export interface EzsignsignatureEditObjectV1Request {
    /**
     * 
     * @type {EzsignsignatureRequest}
     * @memberof EzsignsignatureEditObjectV1Request
     */
    objEzsignsignature?: EzsignsignatureRequest;
}
/**
 * Response for the /1/object/ezsignsignature/editObject API Request
 * @export
 * @interface EzsignsignatureEditObjectV1Response
 */
export interface EzsignsignatureEditObjectV1Response {
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignsignatureEditObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignsignatureEditObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Response for the /1/object/ezsignsignature/getObject API Request
 * @export
 * @interface EzsignsignatureGetObjectV1Response
 */
export interface EzsignsignatureGetObjectV1Response {
    /**
     * Payload for the /1/object/ezsignsignature/getObject API Request
     * @type {object}
     * @memberof EzsignsignatureGetObjectV1Response
     */
    mPayload: object;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof EzsignsignatureGetObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof EzsignsignatureGetObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * An Ezsignsignature Object
 * @export
 * @interface EzsignsignatureRequest
 */
export interface EzsignsignatureRequest {
    /**
     * A reference to a valid Ezsignfoldersignerassociation.  That value is returned after a successful Ezsignfoldersignerassociation Creation. 
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    fkiEzsignfoldersignerassociationID: number;
    /**
     * The page number in the document where to apply the signature
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    iEzsignpagePagenumber: number;
    /**
     * The X coordinate (Horizontal) where to put the signature block on the page.  Coordinate is calculated at 100dpi (dot per inch). So for example, if you want to put the signature block 2 inches from the left border of the page, you would use \"200\" for the X coordinate.
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    iEzsignsignatureX: number;
    /**
     * The Y coordinate (Vertical) where to put the signature block on the page.  Coordinate is calculated at 100dpi (dot per inch). So for example, if you want to put the signature block 3 inches from the top border of the page, you would use \"300\" for the Y coordinate.
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    iEzsignsignatureY: number;
    /**
     * The step when the Ezsignsigner will be invited to sign.  For example, if you say iEzsignsignatureStep=2, that block of signature will be available for signature only after ALL the signatures in step 1 are completed.
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    iEzsignsignatureStep: number;
    /**
     * The type of signature required.  1. **Acknowledgement** is for an acknowledgment of receipt. 2. **Handwritten** is for a handwritten kind of signature where users needs to \"draw\" their signature on screen. 3. **Initials** is a simple \"click to add initials\" block. 4. **Name** is a simple \"Click to sign\" block. This is the most common block of signature.
     * @type {string}
     * @memberof EzsignsignatureRequest
     */
    eEzsignsignatureType: EzsignsignatureRequestEEzsignsignatureTypeEnum;
    /**
     * A reference to a valid Ezsigndocument.  That value is returned after a successful Ezsigndocumentation Creation.
     * @type {number}
     * @memberof EzsignsignatureRequest
     */
    fkiEzsigndocumentID: number;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsignsignatureRequestEEzsignsignatureTypeEnum {
    Acknowledgement = 'Acknowledgement',
    Handwritten = 'Handwritten',
    Initials = 'Initials',
    Name = 'Name'
}

/**
 * An Ezsignsignature Object and children to create a complete structure
 * @export
 * @interface EzsignsignatureRequestCompound
 */
export interface EzsignsignatureRequestCompound {
    /**
     * A reference to a valid Ezsignfoldersignerassociation.  That value is returned after a successful Ezsignfoldersignerassociation Creation. 
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    fkiEzsignfoldersignerassociationID: number;
    /**
     * The page number in the document where to apply the signature
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    iEzsignpagePagenumber: number;
    /**
     * The X coordinate (Horizontal) where to put the signature block on the page.  Coordinate is calculated at 100dpi (dot per inch). So for example, if you want to put the signature block 2 inches from the left border of the page, you would use \"200\" for the X coordinate.
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    iEzsignsignatureX: number;
    /**
     * The Y coordinate (Vertical) where to put the signature block on the page.  Coordinate is calculated at 100dpi (dot per inch). So for example, if you want to put the signature block 3 inches from the top border of the page, you would use \"300\" for the Y coordinate.
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    iEzsignsignatureY: number;
    /**
     * The step when the Ezsignsigner will be invited to sign.  For example, if you say iEzsignsignatureStep=2, that block of signature will be available for signature only after ALL the signatures in step 1 are completed.
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    iEzsignsignatureStep: number;
    /**
     * The type of signature required.  1. **Acknowledgement** is for an acknowledgment of receipt. 2. **Handwritten** is for a handwritten kind of signature where users needs to \"draw\" their signature on screen. 3. **Initials** is a simple \"click to add initials\" block. 4. **Name** is a simple \"Click to sign\" block. This is the most common block of signature.
     * @type {string}
     * @memberof EzsignsignatureRequestCompound
     */
    eEzsignsignatureType: EzsignsignatureRequestCompoundEEzsignsignatureTypeEnum;
    /**
     * A reference to a valid Ezsigndocument.  That value is returned after a successful Ezsigndocumentation Creation.
     * @type {number}
     * @memberof EzsignsignatureRequestCompound
     */
    fkiEzsigndocumentID: number;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsignsignatureRequestCompoundEEzsignsignatureTypeEnum {
    Acknowledgement = 'Acknowledgement',
    Handwritten = 'Handwritten',
    Initials = 'Initials',
    Name = 'Name'
}

/**
 * An Ezsignsigner Object
 * @export
 * @interface EzsignsignerRequest
 */
export interface EzsignsignerRequest {
    /**
     * The unique ID of the Taxassignment.  Valid values:  |Value|Description| |-|-| |1|No tax| |2|GST| |3|HST (ON)| |4|HST (NB)| |5|HST (NS)| |6|HST (NL)| |7|HST (PE)| |8|GST + QST (QC)| |9|GST + QST (QC) Non-Recoverable| |10|GST + PST (BC)| |11|GST + PST (SK)| |12|GST + RST (MB)| |13|GST + PST (BC) Non-Recoverable| |14|GST + PST (SK) Non-Recoverable| |15|GST + RST (MB) Non-Recoverable|
     * @type {number}
     * @memberof EzsignsignerRequest
     */
    fkiTaxassignmentID: number;
    /**
     * The unique ID of the Secretquestion.  Valid values:  |Value|Description| |-|-| |1|The name of the hospital in which you were born| |2|The name of your grade school| |3|The last name of your favorite teacher| |4|Your favorite sports team| |5|Your favorite TV show| |6|Your favorite movie| |7|The name of the street on which you grew up| |8|The name of your first employer| |9|Your first car| |10|Your favorite food| |11|The name of your first pet| |12|Favorite musician/band| |13|What instrument you play| |14|Your father\'s middle name| |15|Your mother\'s maiden name| |16|Name of your eldest child| |17|Your spouse\'s middle name| |18|Favorite restaurant| |19|Childhood nickname| |20|Favorite vacation destination| |21|Your boat\'s name| |22|Date of Birth (YYYY-MM-DD)|
     * @type {number}
     * @memberof EzsignsignerRequest
     */
    fkiSecretquestionID?: number;
    /**
     * The method the Ezsignsigner will authenticate to the signing platform.  1. **Password** means the Ezsignsigner will receive a secure link by email. 2. **PasswordPhone** means the Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**. 3. **PasswordQuestion** means the Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer. 4. **InPersonPhone** means the Ezsignsigner will only be able to sign \"In-Person\" and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**. 5. **InPerson** means the Ezsignsigner will only be able to sign \"In-Person\" and there won\'t be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type.
     * @type {string}
     * @memberof EzsignsignerRequest
     */
    eEzsignsignerLogintype: EzsignsignerRequestEEzsignsignerLogintypeEnum;
    /**
     * The predefined answer to the secret question the Ezsignsigner will need to provide to successfully authenticate.
     * @type {string}
     * @memberof EzsignsignerRequest
     */
    sEzsignsignerSecretanswer?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsignsignerRequestEEzsignsignerLogintypeEnum {
    Password = 'Password',
    PasswordPhone = 'PasswordPhone',
    PasswordQuestion = 'PasswordQuestion',
    InPersonPhone = 'InPersonPhone',
    InPerson = 'InPerson'
}

/**
 * An Ezsignsigner Object and children to create a complete structure
 * @export
 * @interface EzsignsignerRequestCompound
 */
export interface EzsignsignerRequestCompound {
    /**
     * 
     * @type {EzsignsignerRequestCompoundContact}
     * @memberof EzsignsignerRequestCompound
     */
    objContact: EzsignsignerRequestCompoundContact;
    /**
     * The unique ID of the Taxassignment.  Valid values:  |Value|Description| |-|-| |1|No tax| |2|GST| |3|HST (ON)| |4|HST (NB)| |5|HST (NS)| |6|HST (NL)| |7|HST (PE)| |8|GST + QST (QC)| |9|GST + QST (QC) Non-Recoverable| |10|GST + PST (BC)| |11|GST + PST (SK)| |12|GST + RST (MB)| |13|GST + PST (BC) Non-Recoverable| |14|GST + PST (SK) Non-Recoverable| |15|GST + RST (MB) Non-Recoverable|
     * @type {number}
     * @memberof EzsignsignerRequestCompound
     */
    fkiTaxassignmentID: number;
    /**
     * The unique ID of the Secretquestion.  Valid values:  |Value|Description| |-|-| |1|The name of the hospital in which you were born| |2|The name of your grade school| |3|The last name of your favorite teacher| |4|Your favorite sports team| |5|Your favorite TV show| |6|Your favorite movie| |7|The name of the street on which you grew up| |8|The name of your first employer| |9|Your first car| |10|Your favorite food| |11|The name of your first pet| |12|Favorite musician/band| |13|What instrument you play| |14|Your father\'s middle name| |15|Your mother\'s maiden name| |16|Name of your eldest child| |17|Your spouse\'s middle name| |18|Favorite restaurant| |19|Childhood nickname| |20|Favorite vacation destination| |21|Your boat\'s name| |22|Date of Birth (YYYY-MM-DD)|
     * @type {number}
     * @memberof EzsignsignerRequestCompound
     */
    fkiSecretquestionID?: number;
    /**
     * The method the Ezsignsigner will authenticate to the signing platform.  1. **Password** means the Ezsignsigner will receive a secure link by email. 2. **PasswordPhone** means the Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**. 3. **PasswordQuestion** means the Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer. 4. **InPersonPhone** means the Ezsignsigner will only be able to sign \"In-Person\" and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**. 5. **InPerson** means the Ezsignsigner will only be able to sign \"In-Person\" and there won\'t be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type.
     * @type {string}
     * @memberof EzsignsignerRequestCompound
     */
    eEzsignsignerLogintype: EzsignsignerRequestCompoundEEzsignsignerLogintypeEnum;
    /**
     * The predefined answer to the secret question the Ezsignsigner will need to provide to successfully authenticate.
     * @type {string}
     * @memberof EzsignsignerRequestCompound
     */
    sEzsignsignerSecretanswer?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EzsignsignerRequestCompoundEEzsignsignerLogintypeEnum {
    Password = 'Password',
    PasswordPhone = 'PasswordPhone',
    PasswordQuestion = 'PasswordQuestion',
    InPersonPhone = 'InPersonPhone',
    InPerson = 'InPerson'
}

/**
 * A Ezsignsigner->Contact Object and children to create a complete structure
 * @export
 * @interface EzsignsignerRequestCompoundContact
 */
export interface EzsignsignerRequestCompoundContact {
    /**
     * The first name of the Contact
     * @type {string}
     * @memberof EzsignsignerRequestCompoundContact
     */
    sContactFirstname: string;
    /**
     * The last name of the Contact
     * @type {string}
     * @memberof EzsignsignerRequestCompoundContact
     */
    sContactLastname: string;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof EzsignsignerRequestCompoundContact
     */
    fkiLanguageID: number;
    /**
     * The email address of the contact. Must be filled if email authentification was requested
     * @type {string}
     * @memberof EzsignsignerRequestCompoundContact
     */
    sEmailAddress?: string;
    /**
     * The Phone number of the contact. Use format \"5149901516\" for North American Numbers (Without \"1\" for long distance code) you would dial like this: 1-514-990-1516. Use format \"498945233886\" for international numbers (Without \"011\") you would dial like this: +49 89 452 33 88-6. In this example \"49\" is the country code of Germany.
     * @type {string}
     * @memberof EzsignsignerRequestCompoundContact
     */
    sPhoneNumber?: string;
    /**
     * The Cell Phone number of the contact. Use format \"5149901516\" for North American Numbers (Without \"1\" for long distance code) you would dial like this: 1-514-990-1516. Use format \"498945233886\" for international numbers (Without \"011\") you would dial like this: +49 89 452 33 88-6. In this example \"49\" is the country code of Germany.
     * @type {string}
     * @memberof EzsignsignerRequestCompoundContact
     */
    sPhoneNumberCell?: string;
}
/**
 * The signature step of the Ezsigndocument.
 * @export
 * @enum {string}
 */
export enum FieldEEzsigndocumentStep {
    Unsent = 'Unsent',
    Unsigned = 'Unsigned',
    PartiallySigned = 'PartiallySigned',
    Completed = 'Completed'
}

/**
 * Frequency at which reminders will be sent to signers that haven\'t signed the documents
 * @export
 * @enum {string}
 */
export enum FieldEEzsignfolderSendreminderfrequency {
    None = 'None',
    Daily = 'Daily',
    Weekly = 'Weekly'
}

/**
 * The signature step of the Ezsignfolder.
 * @export
 * @enum {string}
 */
export enum FieldEEzsignfolderStep {
    Unsent = 'Unsent',
    Sent = 'Sent',
    PartiallySigned = 'PartiallySigned',
    Expired = 'Expired',
    Signed = 'Signed',
    Completed = 'Completed',
    Archived = 'Archived'
}

/**
 * The type of phone number.  **Local** refers to a north American phone number. You would then need to specify sPhoneRegion, sPhoneExchange, sPhoneNumber. **International** would be used for numbers outside of north america. You would then need to specify sPhoneInternational
 * @export
 * @enum {string}
 */
export enum FieldEPhoneType {
    Local = 'Local',
    International = 'International'
}

/**
 * The user type of the User.
 * @export
 * @enum {string}
 */
export enum FieldEUserType {
    AgentBroker = 'AgentBroker',
    Assistant = 'Assistant',
    Attendance = 'Attendance',
    Customer = 'Customer',
    Employee = 'Employee',
    Ezcom = 'Ezcom',
    EzsignSigner = 'EzsignSigner',
    EzsignUser = 'EzsignUser',
    FranchiseCustomerServer = 'FranchiseCustomerServer',
    Normal = 'Normal',
    RewardAdministration = 'RewardAdministration',
    RewardMember = 'RewardMember',
    RewardRepresentative = 'RewardRepresentative',
    RewardCustomer = 'RewardCustomer',
    RewardDistributorServer = 'RewardDistributorServer',
    Supplier = 'Supplier',
    VetrxCustomer = 'VetrxCustomer',
    Vetrxcustomergroup = 'Vetrxcustomergroup',
    VetrxCustomerServer = 'VetrxCustomerServer',
    VetrxManufacturer = 'VetrxManufacturer',
    VetrxVendor = 'VetrxVendor'
}

/**
 * Request for the /1/object/franchisereferalincome/createObject API Request
 * @export
 * @interface FranchisereferalincomeCreateObjectV1Request
 */
export interface FranchisereferalincomeCreateObjectV1Request {
    /**
     * 
     * @type {FranchisereferalincomeRequest}
     * @memberof FranchisereferalincomeCreateObjectV1Request
     */
    objFranchisereferalincome?: FranchisereferalincomeRequest;
    /**
     * 
     * @type {FranchisereferalincomeRequestCompound}
     * @memberof FranchisereferalincomeCreateObjectV1Request
     */
    objFranchisereferalincomeCompound?: FranchisereferalincomeRequestCompound;
}
/**
 * Response for the /1/object/franchisereferalincome/createObject API Request
 * @export
 * @interface FranchisereferalincomeCreateObjectV1Response
 */
export interface FranchisereferalincomeCreateObjectV1Response {
    /**
     * 
     * @type {FranchisereferalincomeCreateObjectV1ResponseMPayload}
     * @memberof FranchisereferalincomeCreateObjectV1Response
     */
    mPayload: FranchisereferalincomeCreateObjectV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof FranchisereferalincomeCreateObjectV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof FranchisereferalincomeCreateObjectV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/object/franchisereferalincome/createObject API Request
 * @export
 * @interface FranchisereferalincomeCreateObjectV1ResponseMPayload
 */
export interface FranchisereferalincomeCreateObjectV1ResponseMPayload {
    /**
     * An array of unique IDs representing the object that were requested to be created.  They are returned in the same order as the array containing the objects to be created that was sent in the request.
     * @type {Array<number>}
     * @memberof FranchisereferalincomeCreateObjectV1ResponseMPayload
     */
    a_pkiFranchisereferalincomeID: Array<number>;
}
/**
 * An Franchisereferalincome Object
 * @export
 * @interface FranchisereferalincomeRequest
 */
export interface FranchisereferalincomeRequest {
    /**
     * The unique ID of the Franchisebroker
     * @type {number}
     * @memberof FranchisereferalincomeRequest
     */
    fkiFranchisebrokerID: number;
    /**
     * The unique ID of the Franchisereferalincomeprogram
     * @type {number}
     * @memberof FranchisereferalincomeRequest
     */
    fkiFranchisereferalincomeprogramID: number;
    /**
     * The unique ID of the Period
     * @type {number}
     * @memberof FranchisereferalincomeRequest
     */
    fkiPeriodID: number;
    /**
     * The loan amount
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    dFranchisereferalincomeLoan: string;
    /**
     * The amount that will be given to the franchise
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    dFranchisereferalincomeFranchiseamount: string;
    /**
     * The amount that will be kept by the franchisor
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    dFranchisereferalincomeFranchisoramount: string;
    /**
     * The amount that will be given to the agent
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    dFranchisereferalincomeAgentamount: string;
    /**
     * The date the amounts were disbursed
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    dtFranchisereferalincomeDisbursed: string;
    /**
     * A comment about the transaction
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    tFranchisereferalincomeComment: string;
    /**
     * The unique ID of the Franchisereoffice
     * @type {number}
     * @memberof FranchisereferalincomeRequest
     */
    fkiFranchiseofficeID: number;
    /**
     * 
     * @type {string}
     * @memberof FranchisereferalincomeRequest
     */
    sFranchisereferalincomeRemoteid: string;
}
/**
 * A Franchisereferalincome Object and children to create a complete structure
 * @export
 * @interface FranchisereferalincomeRequestCompound
 */
export interface FranchisereferalincomeRequestCompound {
    /**
     * 
     * @type {AddressRequest}
     * @memberof FranchisereferalincomeRequestCompound
     */
    objAddress?: AddressRequest;
    /**
     * 
     * @type {Array<ContactRequestCompound>}
     * @memberof FranchisereferalincomeRequestCompound
     */
    a_objContact: Array<ContactRequestCompound>;
    /**
     * The unique ID of the Franchisebroker
     * @type {number}
     * @memberof FranchisereferalincomeRequestCompound
     */
    fkiFranchisebrokerID: number;
    /**
     * The unique ID of the Franchisereferalincomeprogram
     * @type {number}
     * @memberof FranchisereferalincomeRequestCompound
     */
    fkiFranchisereferalincomeprogramID: number;
    /**
     * The unique ID of the Period
     * @type {number}
     * @memberof FranchisereferalincomeRequestCompound
     */
    fkiPeriodID: number;
    /**
     * The loan amount
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    dFranchisereferalincomeLoan: string;
    /**
     * The amount that will be given to the franchise
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    dFranchisereferalincomeFranchiseamount: string;
    /**
     * The amount that will be kept by the franchisor
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    dFranchisereferalincomeFranchisoramount: string;
    /**
     * The amount that will be given to the agent
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    dFranchisereferalincomeAgentamount: string;
    /**
     * The date the amounts were disbursed
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    dtFranchisereferalincomeDisbursed: string;
    /**
     * A comment about the transaction
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    tFranchisereferalincomeComment: string;
    /**
     * The unique ID of the Franchisereoffice
     * @type {number}
     * @memberof FranchisereferalincomeRequestCompound
     */
    fkiFranchiseofficeID: number;
    /**
     * 
     * @type {string}
     * @memberof FranchisereferalincomeRequestCompound
     */
    sFranchisereferalincomeRemoteid: string;
}
/**
 * Description of the API Key  
 * @export
 * @interface MultilingualApikeyDescription
 */
export interface MultilingualApikeyDescription {
    /**
     * Value in French
     * @type {string}
     * @memberof MultilingualApikeyDescription
     */
    sApikeyDescription1?: string;
    /**
     * Value in English
     * @type {string}
     * @memberof MultilingualApikeyDescription
     */
    sApikeyDescription2?: string;
}
/**
 * A Phone Object
 * @export
 * @interface PhoneRequest
 */
export interface PhoneRequest {
    /**
     * The unique ID of the Phonetype.  Valid values:  |Value|Description| |-|-| |1|Office| |2|Home| |3|Mobile| |4|Fax| |5|Pager| |6|Toll Free|
     * @type {number}
     * @memberof PhoneRequest
     */
    fkiPhonetypeID: number;
    /**
     * 
     * @type {FieldEPhoneType}
     * @memberof PhoneRequest
     */
    ePhoneType: FieldEPhoneType;
    /**
     * The region of the phone number. (For a North America Number only)  The region is the \"514\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof PhoneRequest
     */
    sPhoneRegion?: string;
    /**
     * The exchange of the phone number. (For a North America Number only)  The exchange is the \"990\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof PhoneRequest
     */
    sPhoneExchange?: string;
    /**
     * The number of the phone number. (For a North America Number only)  The number is the \"1516\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof PhoneRequest
     */
    sPhoneNumber?: string;
    /**
     * The international phone number. (For phone numbers outside of North)  Do not specify the \"011\" part of the phone number used to dial an international phone number from North America.  For example for this sample phone number \"+442071838750\", you would send \"442071838750\" without the \"+\" sign.
     * @type {string}
     * @memberof PhoneRequest
     */
    sPhoneInternational?: string;
    /**
     * The extension of the phone number.  The extension is the \"123\" section in this sample phone number: (514) 990-1516 x123.  It can also be used with international phone numbers
     * @type {string}
     * @memberof PhoneRequest
     */
    sPhoneExtension?: string;
}
/**
 * Request for the /1/module/user/createEzsignuser API Request
 * @export
 * @interface UserCreateEzsignuserV1Request
 */
export interface UserCreateEzsignuserV1Request {
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof UserCreateEzsignuserV1Request
     */
    fkiLanguageID: number;
    /**
     * The First name of the user
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sUserFirstname: string;
    /**
     * The Last name of the user
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sUserLastname: string;
    /**
     * The email address.
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sEmailAddress: string;
    /**
     * The region of the phone number. (For a North America Number only)  The region is the \"514\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sPhoneRegion: string;
    /**
     * The exchange of the phone number. (For a North America Number only)  The exchange is the \"990\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sPhoneExchange: string;
    /**
     * The number of the phone number. (For a North America Number only)  The number is the \"1516\" section in this sample phone number: (514) 990-1516 x123
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sPhoneNumber: string;
    /**
     * The extension of the phone number.  The extension is the \"123\" section in this sample phone number: (514) 990-1516 x123.  It can also be used with international phone numbers
     * @type {string}
     * @memberof UserCreateEzsignuserV1Request
     */
    sPhoneExtension?: string;
}
/**
 * Response for the /1/module/user/createEzsignuser API Request
 * @export
 * @interface UserCreateEzsignuserV1Response
 */
export interface UserCreateEzsignuserV1Response {
    /**
     * 
     * @type {UserCreateEzsignuserV1ResponseMPayload}
     * @memberof UserCreateEzsignuserV1Response
     */
    mPayload: UserCreateEzsignuserV1ResponseMPayload;
    /**
     * 
     * @type {CommonResponseObjDebugPayload}
     * @memberof UserCreateEzsignuserV1Response
     */
    objDebugPayload?: CommonResponseObjDebugPayload;
    /**
     * 
     * @type {CommonResponseObjDebug}
     * @memberof UserCreateEzsignuserV1Response
     */
    objDebug?: CommonResponseObjDebug;
}
/**
 * Payload for the /1/module/user/createEzsignuser API Request
 * @export
 * @interface UserCreateEzsignuserV1ResponseMPayload
 */
export interface UserCreateEzsignuserV1ResponseMPayload {
    /**
     * An array of email addresses that succeeded.
     * @type {Array<string>}
     * @memberof UserCreateEzsignuserV1ResponseMPayload
     */
    a_sEmailAddressSuccess: Array<string>;
    /**
     * An array of email addresses that failed.
     * @type {Array<string>}
     * @memberof UserCreateEzsignuserV1ResponseMPayload
     */
    a_sEmailAddressFailure: Array<string>;
}
/**
 * A User Object
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique ID of the User
     * @type {number}
     * @memberof UserResponse
     */
    pkiUserID: number;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof UserResponse
     */
    fkiLanguageID: number;
    /**
     * 
     * @type {FieldEUserType}
     * @memberof UserResponse
     */
    eUserType: FieldEUserType;
    /**
     * The First name of the user
     * @type {string}
     * @memberof UserResponse
     */
    sUserFirstname: string;
    /**
     * The Last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    sUserLastname: string;
    /**
     * The Login name of the User.
     * @type {string}
     * @memberof UserResponse
     */
    sUserLoginname: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof UserResponse
     */
    objAudit: CommonAudit;
}
/**
 * 
 * @export
 * @interface UserResponseAllOf
 */
export interface UserResponseAllOf {
    /**
     * The unique ID of the User
     * @type {number}
     * @memberof UserResponseAllOf
     */
    pkiUserID: number;
    /**
     * The unique ID of the Language.  Valid values:  |Value|Description| |-|-| |1|French| |2|English|
     * @type {number}
     * @memberof UserResponseAllOf
     */
    fkiLanguageID: number;
    /**
     * 
     * @type {FieldEUserType}
     * @memberof UserResponseAllOf
     */
    eUserType: FieldEUserType;
    /**
     * The First name of the user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    sUserFirstname: string;
    /**
     * The Last name of the user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    sUserLastname: string;
    /**
     * The Login name of the User.
     * @type {string}
     * @memberof UserResponseAllOf
     */
    sUserLoginname: string;
    /**
     * 
     * @type {CommonAudit}
     * @memberof UserResponseAllOf
     */
    objAudit: CommonAudit;
}
/**
 * This is the base Webhook object
 * @export
 * @interface WebhookEzsignDocumentCompleted
 */
export interface WebhookEzsignDocumentCompleted {
    /**
     * 
     * @type {EzsigndocumentResponse}
     * @memberof WebhookEzsignDocumentCompleted
     */
    objEzsigndocument: EzsigndocumentResponse;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof WebhookEzsignDocumentCompleted
     */
    objWebhook: WebhookResponse;
    /**
     * An array containing details of previous attempts that were made to deliver the message. The array is empty if it\'s the first attempt.
     * @type {Array<AttemptResponse>}
     * @memberof WebhookEzsignDocumentCompleted
     */
    a_objAttempt: Array<AttemptResponse>;
}
/**
 * 
 * @export
 * @interface WebhookEzsignDocumentCompletedAllOf
 */
export interface WebhookEzsignDocumentCompletedAllOf {
    /**
     * 
     * @type {EzsigndocumentResponse}
     * @memberof WebhookEzsignDocumentCompletedAllOf
     */
    objEzsigndocument: EzsigndocumentResponse;
}
/**
 * This is the base Webhook object
 * @export
 * @interface WebhookEzsignFolderCompleted
 */
export interface WebhookEzsignFolderCompleted {
    /**
     * 
     * @type {EzsignfolderResponse}
     * @memberof WebhookEzsignFolderCompleted
     */
    objEzsignfolder: EzsignfolderResponse;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof WebhookEzsignFolderCompleted
     */
    objWebhook: WebhookResponse;
    /**
     * An array containing details of previous attempts that were made to deliver the message. The array is empty if it\'s the first attempt.
     * @type {Array<AttemptResponse>}
     * @memberof WebhookEzsignFolderCompleted
     */
    a_objAttempt: Array<AttemptResponse>;
}
/**
 * 
 * @export
 * @interface WebhookEzsignFolderCompletedAllOf
 */
export interface WebhookEzsignFolderCompletedAllOf {
    /**
     * 
     * @type {EzsignfolderResponse}
     * @memberof WebhookEzsignFolderCompletedAllOf
     */
    objEzsignfolder: EzsignfolderResponse;
}
/**
 * A webhook object
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The Webhook ID. This value is visible in the admin interface.
     * @type {number}
     * @memberof WebhookResponse
     */
    pkiWebhookID: number;
    /**
     * The Module generating the Event.
     * @type {string}
     * @memberof WebhookResponse
     */
    eWebhookModule: WebhookResponseEWebhookModuleEnum;
    /**
     * This Ezsign Event. This property will be set only if the Module is \"Ezsign\".
     * @type {string}
     * @memberof WebhookResponse
     */
    eWebhookEzsignevent?: WebhookResponseEWebhookEzsigneventEnum;
    /**
     * The Customer Code in which the event was generated
     * @type {string}
     * @memberof WebhookResponse
     */
    pksCustomerCode: string;
    /**
     * The url being called
     * @type {string}
     * @memberof WebhookResponse
     */
    sWebhookUrl: string;
    /**
     * The email that will receive the webhook in case all attempts fail.
     * @type {string}
     * @memberof WebhookResponse
     */
    sWebhookEmailfailed: string;
    /**
     * This Management Event. This property will be set only if the Module is \"Management\".
     * @type {string}
     * @memberof WebhookResponse
     */
    eWebhookManagementevent?: WebhookResponseEWebhookManagementeventEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookResponseEWebhookModuleEnum {
    Ezsign = 'Ezsign',
    Management = 'Management'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookResponseEWebhookEzsigneventEnum {
    DocumentCompleted = 'DocumentCompleted',
    FolderCompleted = 'FolderCompleted'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookResponseEWebhookManagementeventEnum {
    UserCreated = 'UserCreated'
}

/**
 * This is the base Webhook object
 * @export
 * @interface WebhookUserUserCreated
 */
export interface WebhookUserUserCreated {
    /**
     * 
     * @type {UserResponse}
     * @memberof WebhookUserUserCreated
     */
    objUser: UserResponse;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof WebhookUserUserCreated
     */
    objWebhook: WebhookResponse;
    /**
     * An array containing details of previous attempts that were made to deliver the message. The array is empty if it\'s the first attempt.
     * @type {Array<AttemptResponse>}
     * @memberof WebhookUserUserCreated
     */
    a_objAttempt: Array<AttemptResponse>;
}
/**
 * 
 * @export
 * @interface WebhookUserUserCreatedAllOf
 */
export interface WebhookUserUserCreatedAllOf {
    /**
     * 
     * @type {UserResponse}
     * @memberof WebhookUserUserCreatedAllOf
     */
    objUser: UserResponse;
}
/**
 * A Website Object
 * @export
 * @interface WebsiteRequest
 */
export interface WebsiteRequest {
    /**
     * The unique ID of the Websitetype.  Valid values:  |Value|Description| |-|-| |1|Website| |2|Twitter| |3|Facebook| |4|Survey|
     * @type {number}
     * @memberof WebsiteRequest
     */
    fkiWebsitetypeID: number;
    /**
     * The URL of the website.
     * @type {string}
     * @memberof WebsiteRequest
     */
    sWebsiteAddress: string;
}

/**
 * ModuleUserApi - axios parameter creator
 * @export
 */
export const ModuleUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to initiate the creation or a user of type Ezsignuser.  The user will be created only once the email verification process will be completed
         * @summary Create a new User of type Ezsignuser
         * @param {Array<UserCreateEzsignuserV1Request>} userCreateEzsignuserV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateEzsignuserV1: async (userCreateEzsignuserV1Request: Array<UserCreateEzsignuserV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateEzsignuserV1Request' is not null or undefined
            if (userCreateEzsignuserV1Request === null || userCreateEzsignuserV1Request === undefined) {
                throw new RequiredError('userCreateEzsignuserV1Request','Required parameter userCreateEzsignuserV1Request was null or undefined when calling userCreateEzsignuserV1.');
            }
            const localVarPath = `/1/module/user/createezsignuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userCreateEzsignuserV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userCreateEzsignuserV1Request !== undefined ? userCreateEzsignuserV1Request : {})
                : (userCreateEzsignuserV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleUserApi - functional programming interface
 * @export
 */
export const ModuleUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to initiate the creation or a user of type Ezsignuser.  The user will be created only once the email verification process will be completed
         * @summary Create a new User of type Ezsignuser
         * @param {Array<UserCreateEzsignuserV1Request>} userCreateEzsignuserV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateEzsignuserV1(userCreateEzsignuserV1Request: Array<UserCreateEzsignuserV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreateEzsignuserV1Response>> {
            const localVarAxiosArgs = await ModuleUserApiAxiosParamCreator(configuration).userCreateEzsignuserV1(userCreateEzsignuserV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ModuleUserApi - factory interface
 * @export
 */
export const ModuleUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to initiate the creation or a user of type Ezsignuser.  The user will be created only once the email verification process will be completed
         * @summary Create a new User of type Ezsignuser
         * @param {Array<UserCreateEzsignuserV1Request>} userCreateEzsignuserV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateEzsignuserV1(userCreateEzsignuserV1Request: Array<UserCreateEzsignuserV1Request>, options?: any): AxiosPromise<UserCreateEzsignuserV1Response> {
            return ModuleUserApiFp(configuration).userCreateEzsignuserV1(userCreateEzsignuserV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModuleUserApi - object-oriented interface
 * @export
 * @class ModuleUserApi
 * @extends {BaseAPI}
 */
export class ModuleUserApi extends BaseAPI {
    /**
     * The endpoint allows to initiate the creation or a user of type Ezsignuser.  The user will be created only once the email verification process will be completed
     * @summary Create a new User of type Ezsignuser
     * @param {Array<UserCreateEzsignuserV1Request>} userCreateEzsignuserV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleUserApi
     */
    public userCreateEzsignuserV1(userCreateEzsignuserV1Request: Array<UserCreateEzsignuserV1Request>, options?: any) {
        return ModuleUserApiFp(this.configuration).userCreateEzsignuserV1(userCreateEzsignuserV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectActivesessionApi - axios parameter creator
 * @export
 */
export const ObjectActivesessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the details about the current activesession
         * @summary Get Current Activesession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activesessionGetCurrentV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/object/activesession/getCurrent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectActivesessionApi - functional programming interface
 * @export
 */
export const ObjectActivesessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve the details about the current activesession
         * @summary Get Current Activesession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activesessionGetCurrentV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivesessionGetCurrentV1Response>> {
            const localVarAxiosArgs = await ObjectActivesessionApiAxiosParamCreator(configuration).activesessionGetCurrentV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectActivesessionApi - factory interface
 * @export
 */
export const ObjectActivesessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieve the details about the current activesession
         * @summary Get Current Activesession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activesessionGetCurrentV1(options?: any): AxiosPromise<ActivesessionGetCurrentV1Response> {
            return ObjectActivesessionApiFp(configuration).activesessionGetCurrentV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectActivesessionApi - object-oriented interface
 * @export
 * @class ObjectActivesessionApi
 * @extends {BaseAPI}
 */
export class ObjectActivesessionApi extends BaseAPI {
    /**
     * Retrieve the details about the current activesession
     * @summary Get Current Activesession
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectActivesessionApi
     */
    public activesessionGetCurrentV1(options?: any) {
        return ObjectActivesessionApiFp(this.configuration).activesessionGetCurrentV1(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectApikeyApi - axios parameter creator
 * @export
 */
export const ObjectApikeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Apikey
         * @param {Array<ApikeyCreateObjectV1Request>} apikeyCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyCreateObjectV1: async (apikeyCreateObjectV1Request: Array<ApikeyCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikeyCreateObjectV1Request' is not null or undefined
            if (apikeyCreateObjectV1Request === null || apikeyCreateObjectV1Request === undefined) {
                throw new RequiredError('apikeyCreateObjectV1Request','Required parameter apikeyCreateObjectV1Request was null or undefined when calling apikeyCreateObjectV1.');
            }
            const localVarPath = `/1/object/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof apikeyCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(apikeyCreateObjectV1Request !== undefined ? apikeyCreateObjectV1Request : {})
                : (apikeyCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectApikeyApi - functional programming interface
 * @export
 */
export const ObjectApikeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Apikey
         * @param {Array<ApikeyCreateObjectV1Request>} apikeyCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeyCreateObjectV1(apikeyCreateObjectV1Request: Array<ApikeyCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApikeyCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectApikeyApiAxiosParamCreator(configuration).apikeyCreateObjectV1(apikeyCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectApikeyApi - factory interface
 * @export
 */
export const ObjectApikeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Apikey
         * @param {Array<ApikeyCreateObjectV1Request>} apikeyCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyCreateObjectV1(apikeyCreateObjectV1Request: Array<ApikeyCreateObjectV1Request>, options?: any): AxiosPromise<ApikeyCreateObjectV1Response> {
            return ObjectApikeyApiFp(configuration).apikeyCreateObjectV1(apikeyCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectApikeyApi - object-oriented interface
 * @export
 * @class ObjectApikeyApi
 * @extends {BaseAPI}
 */
export class ObjectApikeyApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Apikey
     * @param {Array<ApikeyCreateObjectV1Request>} apikeyCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApikeyApi
     */
    public apikeyCreateObjectV1(apikeyCreateObjectV1Request: Array<ApikeyCreateObjectV1Request>, options?: any) {
        return ObjectApikeyApiFp(this.configuration).apikeyCreateObjectV1(apikeyCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectEzsigndocumentApi - axios parameter creator
 * @export
 */
export const ObjectEzsigndocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
         * @summary Apply an Ezsign Template to the Ezsigndocument.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentApplyEzsigntemplateV1Request} ezsigndocumentApplyEzsigntemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentApplyEzsigntemplateV1: async (pkiEzsigndocumentID: number, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentApplyEzsigntemplateV1.');
            }
            // verify required parameter 'ezsigndocumentApplyEzsigntemplateV1Request' is not null or undefined
            if (ezsigndocumentApplyEzsigntemplateV1Request === null || ezsigndocumentApplyEzsigntemplateV1Request === undefined) {
                throw new RequiredError('ezsigndocumentApplyEzsigntemplateV1Request','Required parameter ezsigndocumentApplyEzsigntemplateV1Request was null or undefined when calling ezsigndocumentApplyEzsigntemplateV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}/applyezsigntemplate`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsigndocumentApplyEzsigntemplateV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsigndocumentApplyEzsigntemplateV1Request !== undefined ? ezsigndocumentApplyEzsigntemplateV1Request : {})
                : (ezsigndocumentApplyEzsigntemplateV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsigndocument
         * @param {Array<EzsigndocumentCreateObjectV1Request>} ezsigndocumentCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentCreateObjectV1: async (ezsigndocumentCreateObjectV1Request: Array<EzsigndocumentCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsigndocumentCreateObjectV1Request' is not null or undefined
            if (ezsigndocumentCreateObjectV1Request === null || ezsigndocumentCreateObjectV1Request === undefined) {
                throw new RequiredError('ezsigndocumentCreateObjectV1Request','Required parameter ezsigndocumentCreateObjectV1Request was null or undefined when calling ezsigndocumentCreateObjectV1.');
            }
            const localVarPath = `/1/object/ezsigndocument`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsigndocumentCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsigndocumentCreateObjectV1Request !== undefined ? ezsigndocumentCreateObjectV1Request : {})
                : (ezsigndocumentCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentDeleteObjectV1: async (pkiEzsigndocumentID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentDeleteObjectV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentEditObjectV1Request} ezsigndocumentEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentEditObjectV1: async (pkiEzsigndocumentID: number, ezsigndocumentEditObjectV1Request: EzsigndocumentEditObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentEditObjectV1.');
            }
            // verify required parameter 'ezsigndocumentEditObjectV1Request' is not null or undefined
            if (ezsigndocumentEditObjectV1Request === null || ezsigndocumentEditObjectV1Request === undefined) {
                throw new RequiredError('ezsigndocumentEditObjectV1Request','Required parameter ezsigndocumentEditObjectV1Request was null or undefined when calling ezsigndocumentEditObjectV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsigndocumentEditObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsigndocumentEditObjectV1Request !== undefined ? ezsigndocumentEditObjectV1Request : {})
                : (ezsigndocumentEditObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
         * @summary Retrieve a URL to download documents.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {'Initial' | 'Signed' | 'Proof' | 'Proofdocument'} eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **Signed** Is the final document once all signatures were applied. 3. **Proofdocument** Is the evidence report. 4. **Proof** Is the complete evidence archive including all of the above and more. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetDownloadUrlV1: async (pkiEzsigndocumentID: number, eDocumentType: 'Initial' | 'Signed' | 'Proof' | 'Proofdocument', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentGetDownloadUrlV1.');
            }
            // verify required parameter 'eDocumentType' is not null or undefined
            if (eDocumentType === null || eDocumentType === undefined) {
                throw new RequiredError('eDocumentType','Required parameter eDocumentType was null or undefined when calling ezsigndocumentGetDownloadUrlV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}/getDownloadUrl/{eDocumentType}`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)))
                .replace(`{${"eDocumentType"}}`, encodeURIComponent(String(eDocumentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument\'s children IDs
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetObjectGetChildrenV1: async (pkiEzsigndocumentID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentGetObjectGetChildrenV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}/getChildren`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetObjectV1: async (pkiEzsigndocumentID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsigndocumentID' is not null or undefined
            if (pkiEzsigndocumentID === null || pkiEzsigndocumentID === undefined) {
                throw new RequiredError('pkiEzsigndocumentID','Required parameter pkiEzsigndocumentID was null or undefined when calling ezsigndocumentGetObjectV1.');
            }
            const localVarPath = `/1/object/ezsigndocument/{pkiEzsigndocumentID}`
                .replace(`{${"pkiEzsigndocumentID"}}`, encodeURIComponent(String(pkiEzsigndocumentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsigndocumentApi - functional programming interface
 * @export
 */
export const ObjectEzsigndocumentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
         * @summary Apply an Ezsign Template to the Ezsigndocument.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentApplyEzsigntemplateV1Request} ezsigndocumentApplyEzsigntemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID: number, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentApplyEzsigntemplateV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsigndocument
         * @param {Array<EzsigndocumentCreateObjectV1Request>} ezsigndocumentCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request: Array<EzsigndocumentCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentDeleteObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentEditObjectV1Request} ezsigndocumentEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentEditObjectV1(pkiEzsigndocumentID: number, ezsigndocumentEditObjectV1Request: EzsigndocumentEditObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentEditObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentEditObjectV1(pkiEzsigndocumentID, ezsigndocumentEditObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
         * @summary Retrieve a URL to download documents.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {'Initial' | 'Signed' | 'Proof' | 'Proofdocument'} eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **Signed** Is the final document once all signatures were applied. 3. **Proofdocument** Is the evidence report. 4. **Proof** Is the complete evidence archive including all of the above and more. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID: number, eDocumentType: 'Initial' | 'Signed' | 'Proof' | 'Proofdocument', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentGetDownloadUrlV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID, eDocumentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument\'s children IDs
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsigndocumentGetObjectV1(pkiEzsigndocumentID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsigndocumentGetObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsigndocumentApiAxiosParamCreator(configuration).ezsigndocumentGetObjectV1(pkiEzsigndocumentID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectEzsigndocumentApi - factory interface
 * @export
 */
export const ObjectEzsigndocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
         * @summary Apply an Ezsign Template to the Ezsigndocument.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentApplyEzsigntemplateV1Request} ezsigndocumentApplyEzsigntemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID: number, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request, options?: any): AxiosPromise<EzsigndocumentApplyEzsigntemplateV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsigndocument
         * @param {Array<EzsigndocumentCreateObjectV1Request>} ezsigndocumentCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request: Array<EzsigndocumentCreateObjectV1Request>, options?: any): AxiosPromise<EzsigndocumentCreateObjectV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID: number, options?: any): AxiosPromise<EzsigndocumentDeleteObjectV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {EzsigndocumentEditObjectV1Request} ezsigndocumentEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentEditObjectV1(pkiEzsigndocumentID: number, ezsigndocumentEditObjectV1Request: EzsigndocumentEditObjectV1Request, options?: any): AxiosPromise<EzsigndocumentEditObjectV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentEditObjectV1(pkiEzsigndocumentID, ezsigndocumentEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
         * @summary Retrieve a URL to download documents.
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {'Initial' | 'Signed' | 'Proof' | 'Proofdocument'} eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **Signed** Is the final document once all signatures were applied. 3. **Proofdocument** Is the evidence report. 4. **Proof** Is the complete evidence archive including all of the above and more. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID: number, eDocumentType: 'Initial' | 'Signed' | 'Proof' | 'Proofdocument', options?: any): AxiosPromise<EzsigndocumentGetDownloadUrlV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID, eDocumentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument\'s children IDs
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID: number, options?: any): AxiosPromise<void> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsigndocument
         * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsigndocumentGetObjectV1(pkiEzsigndocumentID: number, options?: any): AxiosPromise<EzsigndocumentGetObjectV1Response> {
            return ObjectEzsigndocumentApiFp(configuration).ezsigndocumentGetObjectV1(pkiEzsigndocumentID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsigndocumentApi - object-oriented interface
 * @export
 * @class ObjectEzsigndocumentApi
 * @extends {BaseAPI}
 */
export class ObjectEzsigndocumentApi extends BaseAPI {
    /**
     * This endpoint applies a predefined template to the ezsign document. This allows to automatically apply all the form and signature fields on a document in a single step.  The document must not already have fields otherwise an error will be returned.
     * @summary Apply an Ezsign Template to the Ezsigndocument.
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {EzsigndocumentApplyEzsigntemplateV1Request} ezsigndocumentApplyEzsigntemplateV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID: number, ezsigndocumentApplyEzsigntemplateV1Request: EzsigndocumentApplyEzsigntemplateV1Request, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentApplyEzsigntemplateV1(pkiEzsigndocumentID, ezsigndocumentApplyEzsigntemplateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsigndocument
     * @param {Array<EzsigndocumentCreateObjectV1Request>} ezsigndocumentCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request: Array<EzsigndocumentCreateObjectV1Request>, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentCreateObjectV1(ezsigndocumentCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsigndocument
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID: number, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentDeleteObjectV1(pkiEzsigndocumentID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing Ezsigndocument
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {EzsigndocumentEditObjectV1Request} ezsigndocumentEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentEditObjectV1(pkiEzsigndocumentID: number, ezsigndocumentEditObjectV1Request: EzsigndocumentEditObjectV1Request, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentEditObjectV1(pkiEzsigndocumentID, ezsigndocumentEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns URLs to different files that can be downloaded during the signing process.  These links will expire after 5 minutes so the download of the file should be made soon after retrieving the link.
     * @summary Retrieve a URL to download documents.
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {'Initial' | 'Signed' | 'Proof' | 'Proofdocument'} eDocumentType The type of document to retrieve.  1. **Initial** Is the initial document before any signature were applied. 2. **Signed** Is the final document once all signatures were applied. 3. **Proofdocument** Is the evidence report. 4. **Proof** Is the complete evidence archive including all of the above and more. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID: number, eDocumentType: 'Initial' | 'Signed' | 'Proof' | 'Proofdocument', options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentGetDownloadUrlV1(pkiEzsigndocumentID, eDocumentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsigndocument\'s children IDs
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID: number, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentGetObjectGetChildrenV1(pkiEzsigndocumentID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsigndocument
     * @param {number} pkiEzsigndocumentID The unique ID of the Ezsigndocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsigndocumentApi
     */
    public ezsigndocumentGetObjectV1(pkiEzsigndocumentID: number, options?: any) {
        return ObjectEzsigndocumentApiFp(this.configuration).ezsigndocumentGetObjectV1(pkiEzsigndocumentID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectEzsignfolderApi - axios parameter creator
 * @export
 */
export const ObjectEzsignfolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1: async (ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV1Request' is not null or undefined
            if (ezsignfolderCreateObjectV1Request === null || ezsignfolderCreateObjectV1Request === undefined) {
                throw new RequiredError('ezsignfolderCreateObjectV1Request','Required parameter ezsignfolderCreateObjectV1Request was null or undefined when calling ezsignfolderCreateObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignfolderCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignfolderCreateObjectV1Request !== undefined ? ezsignfolderCreateObjectV1Request : {})
                : (ezsignfolderCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1: async (pkiEzsignfolderID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            if (pkiEzsignfolderID === null || pkiEzsignfolderID === undefined) {
                throw new RequiredError('pkiEzsignfolderID','Required parameter pkiEzsignfolderID was null or undefined when calling ezsignfolderDeleteObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV1: async (pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            if (pkiEzsignfolderID === null || pkiEzsignfolderID === undefined) {
                throw new RequiredError('pkiEzsignfolderID','Required parameter pkiEzsignfolderID was null or undefined when calling ezsignfolderEditObjectV1.');
            }
            // verify required parameter 'ezsignfolderEditObjectV1Request' is not null or undefined
            if (ezsignfolderEditObjectV1Request === null || ezsignfolderEditObjectV1Request === undefined) {
                throw new RequiredError('ezsignfolderEditObjectV1Request','Required parameter ezsignfolderEditObjectV1Request was null or undefined when calling ezsignfolderEditObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignfolderEditObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignfolderEditObjectV1Request !== undefined ? ezsignfolderEditObjectV1Request : {})
                : (ezsignfolderEditObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s children IDs
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectGetChildrenV1: async (pkiEzsignfolderID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            if (pkiEzsignfolderID === null || pkiEzsignfolderID === undefined) {
                throw new RequiredError('pkiEzsignfolderID','Required parameter pkiEzsignfolderID was null or undefined when calling ezsignfolderGetObjectGetChildrenV1.');
            }
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getChildren`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1: async (pkiEzsignfolderID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            if (pkiEzsignfolderID === null || pkiEzsignfolderID === undefined) {
                throw new RequiredError('pkiEzsignfolderID','Required parameter pkiEzsignfolderID was null or undefined when calling ezsignfolderGetObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV1: async (pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            if (pkiEzsignfolderID === null || pkiEzsignfolderID === undefined) {
                throw new RequiredError('pkiEzsignfolderID','Required parameter pkiEzsignfolderID was null or undefined when calling ezsignfolderSendV1.');
            }
            // verify required parameter 'ezsignfolderSendV1Request' is not null or undefined
            if (ezsignfolderSendV1Request === null || ezsignfolderSendV1Request === undefined) {
                throw new RequiredError('ezsignfolderSendV1Request','Required parameter ezsignfolderSendV1Request was null or undefined when calling ezsignfolderSendV1.');
            }
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignfolderSendV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignfolderSendV1Request !== undefined ? ezsignfolderSendV1Request : {})
                : (ezsignfolderSendV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsignfolderApi - functional programming interface
 * @export
 */
export const ObjectEzsignfolderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderDeleteObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderEditObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s children IDs
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderGetObjectV1(pkiEzsignfolderID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderSendV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfolderApiAxiosParamCreator(configuration).ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectEzsignfolderApi - factory interface
 * @export
 */
export const ObjectEzsignfolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: any): AxiosPromise<EzsignfolderCreateObjectV1Response> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderDeleteObjectV1Response> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: any): AxiosPromise<EzsignfolderEditObjectV1Response> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s children IDs
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<void> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetObjectV1Response> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: any): AxiosPromise<EzsignfolderSendV1Response> {
            return ObjectEzsignfolderApiFp(configuration).ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsignfolderApi - object-oriented interface
 * @export
 * @class ObjectEzsignfolderApi
 * @extends {BaseAPI}
 */
export class ObjectEzsignfolderApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsignfolder
     * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
     * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s children IDs
     * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID: number, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectGetChildrenV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID The unique ID of the Ezsignfolder
     * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: any) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectEzsignfoldersignerassociationApi - axios parameter creator
 * @export
 */
export const ObjectEzsignfoldersignerassociationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfoldersignerassociation
         * @param {Array<EzsignfoldersignerassociationCreateObjectV1Request>} ezsignfoldersignerassociationCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationCreateObjectV1: async (ezsignfoldersignerassociationCreateObjectV1Request: Array<EzsignfoldersignerassociationCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfoldersignerassociationCreateObjectV1Request' is not null or undefined
            if (ezsignfoldersignerassociationCreateObjectV1Request === null || ezsignfoldersignerassociationCreateObjectV1Request === undefined) {
                throw new RequiredError('ezsignfoldersignerassociationCreateObjectV1Request','Required parameter ezsignfoldersignerassociationCreateObjectV1Request was null or undefined when calling ezsignfoldersignerassociationCreateObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignfoldersignerassociationCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignfoldersignerassociationCreateObjectV1Request !== undefined ? ezsignfoldersignerassociationCreateObjectV1Request : {})
                : (ezsignfoldersignerassociationCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationDeleteObjectV1: async (pkiEzsignfoldersignerassociationID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfoldersignerassociationID' is not null or undefined
            if (pkiEzsignfoldersignerassociationID === null || pkiEzsignfoldersignerassociationID === undefined) {
                throw new RequiredError('pkiEzsignfoldersignerassociationID','Required parameter pkiEzsignfoldersignerassociationID was null or undefined when calling ezsignfoldersignerassociationDeleteObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}`
                .replace(`{${"pkiEzsignfoldersignerassociationID"}}`, encodeURIComponent(String(pkiEzsignfoldersignerassociationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {EzsignfoldersignerassociationEditObjectV1Request} ezsignfoldersignerassociationEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationEditObjectV1: async (pkiEzsignfoldersignerassociationID: number, ezsignfoldersignerassociationEditObjectV1Request: EzsignfoldersignerassociationEditObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfoldersignerassociationID' is not null or undefined
            if (pkiEzsignfoldersignerassociationID === null || pkiEzsignfoldersignerassociationID === undefined) {
                throw new RequiredError('pkiEzsignfoldersignerassociationID','Required parameter pkiEzsignfoldersignerassociationID was null or undefined when calling ezsignfoldersignerassociationEditObjectV1.');
            }
            // verify required parameter 'ezsignfoldersignerassociationEditObjectV1Request' is not null or undefined
            if (ezsignfoldersignerassociationEditObjectV1Request === null || ezsignfoldersignerassociationEditObjectV1Request === undefined) {
                throw new RequiredError('ezsignfoldersignerassociationEditObjectV1Request','Required parameter ezsignfoldersignerassociationEditObjectV1Request was null or undefined when calling ezsignfoldersignerassociationEditObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}`
                .replace(`{${"pkiEzsignfoldersignerassociationID"}}`, encodeURIComponent(String(pkiEzsignfoldersignerassociationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignfoldersignerassociationEditObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignfoldersignerassociationEditObjectV1Request !== undefined ? ezsignfoldersignerassociationEditObjectV1Request : {})
                : (ezsignfoldersignerassociationEditObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a Login Url that can be used in a browser or embedded in an I-Frame to allow in person signing.  The signer Login type must be configured as In-Person.
         * @summary Retrieve a Login Url to allow In-Person signing
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetInPersonLoginUrlV1: async (pkiEzsignfoldersignerassociationID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfoldersignerassociationID' is not null or undefined
            if (pkiEzsignfoldersignerassociationID === null || pkiEzsignfoldersignerassociationID === undefined) {
                throw new RequiredError('pkiEzsignfoldersignerassociationID','Required parameter pkiEzsignfoldersignerassociationID was null or undefined when calling ezsignfoldersignerassociationGetInPersonLoginUrlV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/getInPersonLoginUrl`
                .replace(`{${"pkiEzsignfoldersignerassociationID"}}`, encodeURIComponent(String(pkiEzsignfoldersignerassociationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation\'s children IDs
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetObjectGetChildrenV1: async (pkiEzsignfoldersignerassociationID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfoldersignerassociationID' is not null or undefined
            if (pkiEzsignfoldersignerassociationID === null || pkiEzsignfoldersignerassociationID === undefined) {
                throw new RequiredError('pkiEzsignfoldersignerassociationID','Required parameter pkiEzsignfoldersignerassociationID was null or undefined when calling ezsignfoldersignerassociationGetObjectGetChildrenV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/getChildren`
                .replace(`{${"pkiEzsignfoldersignerassociationID"}}`, encodeURIComponent(String(pkiEzsignfoldersignerassociationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetObjectV1: async (pkiEzsignfoldersignerassociationID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfoldersignerassociationID' is not null or undefined
            if (pkiEzsignfoldersignerassociationID === null || pkiEzsignfoldersignerassociationID === undefined) {
                throw new RequiredError('pkiEzsignfoldersignerassociationID','Required parameter pkiEzsignfoldersignerassociationID was null or undefined when calling ezsignfoldersignerassociationGetObjectV1.');
            }
            const localVarPath = `/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}`
                .replace(`{${"pkiEzsignfoldersignerassociationID"}}`, encodeURIComponent(String(pkiEzsignfoldersignerassociationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsignfoldersignerassociationApi - functional programming interface
 * @export
 */
export const ObjectEzsignfoldersignerassociationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfoldersignerassociation
         * @param {Array<EzsignfoldersignerassociationCreateObjectV1Request>} ezsignfoldersignerassociationCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request: Array<EzsignfoldersignerassociationCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfoldersignerassociationCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfoldersignerassociationDeleteObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {EzsignfoldersignerassociationEditObjectV1Request} ezsignfoldersignerassociationEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID: number, ezsignfoldersignerassociationEditObjectV1Request: EzsignfoldersignerassociationEditObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfoldersignerassociationEditObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID, ezsignfoldersignerassociationEditObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns a Login Url that can be used in a browser or embedded in an I-Frame to allow in person signing.  The signer Login type must be configured as In-Person.
         * @summary Retrieve a Login Url to allow In-Person signing
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfoldersignerassociationGetInPersonLoginUrlV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation\'s children IDs
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfoldersignerassociationGetObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignfoldersignerassociationApiAxiosParamCreator(configuration).ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectEzsignfoldersignerassociationApi - factory interface
 * @export
 */
export const ObjectEzsignfoldersignerassociationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfoldersignerassociation
         * @param {Array<EzsignfoldersignerassociationCreateObjectV1Request>} ezsignfoldersignerassociationCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request: Array<EzsignfoldersignerassociationCreateObjectV1Request>, options?: any): AxiosPromise<EzsignfoldersignerassociationCreateObjectV1Response> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any): AxiosPromise<EzsignfoldersignerassociationDeleteObjectV1Response> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {EzsignfoldersignerassociationEditObjectV1Request} ezsignfoldersignerassociationEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID: number, ezsignfoldersignerassociationEditObjectV1Request: EzsignfoldersignerassociationEditObjectV1Request, options?: any): AxiosPromise<EzsignfoldersignerassociationEditObjectV1Response> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID, ezsignfoldersignerassociationEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a Login Url that can be used in a browser or embedded in an I-Frame to allow in person signing.  The signer Login type must be configured as In-Person.
         * @summary Retrieve a Login Url to allow In-Person signing
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID: number, options?: any): AxiosPromise<EzsignfoldersignerassociationGetInPersonLoginUrlV1Response> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation\'s children IDs
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID: number, options?: any): AxiosPromise<void> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfoldersignerassociation
         * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any): AxiosPromise<EzsignfoldersignerassociationGetObjectV1Response> {
            return ObjectEzsignfoldersignerassociationApiFp(configuration).ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsignfoldersignerassociationApi - object-oriented interface
 * @export
 * @class ObjectEzsignfoldersignerassociationApi
 * @extends {BaseAPI}
 */
export class ObjectEzsignfoldersignerassociationApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsignfoldersignerassociation
     * @param {Array<EzsignfoldersignerassociationCreateObjectV1Request>} ezsignfoldersignerassociationCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request: Array<EzsignfoldersignerassociationCreateObjectV1Request>, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationCreateObjectV1(ezsignfoldersignerassociationCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsignfoldersignerassociation
     * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationDeleteObjectV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing Ezsignfoldersignerassociation
     * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
     * @param {EzsignfoldersignerassociationEditObjectV1Request} ezsignfoldersignerassociationEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID: number, ezsignfoldersignerassociationEditObjectV1Request: EzsignfoldersignerassociationEditObjectV1Request, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationEditObjectV1(pkiEzsignfoldersignerassociationID, ezsignfoldersignerassociationEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a Login Url that can be used in a browser or embedded in an I-Frame to allow in person signing.  The signer Login type must be configured as In-Person.
     * @summary Retrieve a Login Url to allow In-Person signing
     * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID: number, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationGetInPersonLoginUrlV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfoldersignerassociation\'s children IDs
     * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID: number, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationGetObjectGetChildrenV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfoldersignerassociation
     * @param {number} pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfoldersignerassociationApi
     */
    public ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID: number, options?: any) {
        return ObjectEzsignfoldersignerassociationApiFp(this.configuration).ezsignfoldersignerassociationGetObjectV1(pkiEzsignfoldersignerassociationID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectEzsignsignatureApi - axios parameter creator
 * @export
 */
export const ObjectEzsignsignatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignsignature
         * @param {Array<EzsignsignatureCreateObjectV1Request>} ezsignsignatureCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureCreateObjectV1: async (ezsignsignatureCreateObjectV1Request: Array<EzsignsignatureCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignsignatureCreateObjectV1Request' is not null or undefined
            if (ezsignsignatureCreateObjectV1Request === null || ezsignsignatureCreateObjectV1Request === undefined) {
                throw new RequiredError('ezsignsignatureCreateObjectV1Request','Required parameter ezsignsignatureCreateObjectV1Request was null or undefined when calling ezsignsignatureCreateObjectV1.');
            }
            const localVarPath = `/1/object/ezsignsignature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignsignatureCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignsignatureCreateObjectV1Request !== undefined ? ezsignsignatureCreateObjectV1Request : {})
                : (ezsignsignatureCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureDeleteObjectV1: async (pkiEzsignsignatureID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignsignatureID' is not null or undefined
            if (pkiEzsignsignatureID === null || pkiEzsignsignatureID === undefined) {
                throw new RequiredError('pkiEzsignsignatureID','Required parameter pkiEzsignsignatureID was null or undefined when calling ezsignsignatureDeleteObjectV1.');
            }
            const localVarPath = `/1/object/ezsignsignature/{pkiEzsignsignatureID}`
                .replace(`{${"pkiEzsignsignatureID"}}`, encodeURIComponent(String(pkiEzsignsignatureID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {EzsignsignatureEditObjectV1Request} ezsignsignatureEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureEditObjectV1: async (pkiEzsignsignatureID: number, ezsignsignatureEditObjectV1Request: EzsignsignatureEditObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignsignatureID' is not null or undefined
            if (pkiEzsignsignatureID === null || pkiEzsignsignatureID === undefined) {
                throw new RequiredError('pkiEzsignsignatureID','Required parameter pkiEzsignsignatureID was null or undefined when calling ezsignsignatureEditObjectV1.');
            }
            // verify required parameter 'ezsignsignatureEditObjectV1Request' is not null or undefined
            if (ezsignsignatureEditObjectV1Request === null || ezsignsignatureEditObjectV1Request === undefined) {
                throw new RequiredError('ezsignsignatureEditObjectV1Request','Required parameter ezsignsignatureEditObjectV1Request was null or undefined when calling ezsignsignatureEditObjectV1.');
            }
            const localVarPath = `/1/object/ezsignsignature/{pkiEzsignsignatureID}`
                .replace(`{${"pkiEzsignsignatureID"}}`, encodeURIComponent(String(pkiEzsignsignatureID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ezsignsignatureEditObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ezsignsignatureEditObjectV1Request !== undefined ? ezsignsignatureEditObjectV1Request : {})
                : (ezsignsignatureEditObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature\'s children IDs
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureGetObjectGetChildrenV1: async (pkiEzsignsignatureID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignsignatureID' is not null or undefined
            if (pkiEzsignsignatureID === null || pkiEzsignsignatureID === undefined) {
                throw new RequiredError('pkiEzsignsignatureID','Required parameter pkiEzsignsignatureID was null or undefined when calling ezsignsignatureGetObjectGetChildrenV1.');
            }
            const localVarPath = `/1/object/ezsignsignature/{pkiEzsignsignatureID}/getChildren`
                .replace(`{${"pkiEzsignsignatureID"}}`, encodeURIComponent(String(pkiEzsignsignatureID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureGetObjectV1: async (pkiEzsignsignatureID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignsignatureID' is not null or undefined
            if (pkiEzsignsignatureID === null || pkiEzsignsignatureID === undefined) {
                throw new RequiredError('pkiEzsignsignatureID','Required parameter pkiEzsignsignatureID was null or undefined when calling ezsignsignatureGetObjectV1.');
            }
            const localVarPath = `/1/object/ezsignsignature/{pkiEzsignsignatureID}`
                .replace(`{${"pkiEzsignsignatureID"}}`, encodeURIComponent(String(pkiEzsignsignatureID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsignsignatureApi - functional programming interface
 * @export
 */
export const ObjectEzsignsignatureApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignsignature
         * @param {Array<EzsignsignatureCreateObjectV1Request>} ezsignsignatureCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request: Array<EzsignsignatureCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignsignatureCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignsignatureApiAxiosParamCreator(configuration).ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignsignatureDeleteObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignsignatureApiAxiosParamCreator(configuration).ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {EzsignsignatureEditObjectV1Request} ezsignsignatureEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignsignatureEditObjectV1(pkiEzsignsignatureID: number, ezsignsignatureEditObjectV1Request: EzsignsignatureEditObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignsignatureEditObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignsignatureApiAxiosParamCreator(configuration).ezsignsignatureEditObjectV1(pkiEzsignsignatureID, ezsignsignatureEditObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature\'s children IDs
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ObjectEzsignsignatureApiAxiosParamCreator(configuration).ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignsignatureGetObjectV1(pkiEzsignsignatureID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignsignatureGetObjectV1Response>> {
            const localVarAxiosArgs = await ObjectEzsignsignatureApiAxiosParamCreator(configuration).ezsignsignatureGetObjectV1(pkiEzsignsignatureID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectEzsignsignatureApi - factory interface
 * @export
 */
export const ObjectEzsignsignatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignsignature
         * @param {Array<EzsignsignatureCreateObjectV1Request>} ezsignsignatureCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request: Array<EzsignsignatureCreateObjectV1Request>, options?: any): AxiosPromise<EzsignsignatureCreateObjectV1Response> {
            return ObjectEzsignsignatureApiFp(configuration).ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID: number, options?: any): AxiosPromise<EzsignsignatureDeleteObjectV1Response> {
            return ObjectEzsignsignatureApiFp(configuration).ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {EzsignsignatureEditObjectV1Request} ezsignsignatureEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureEditObjectV1(pkiEzsignsignatureID: number, ezsignsignatureEditObjectV1Request: EzsignsignatureEditObjectV1Request, options?: any): AxiosPromise<EzsignsignatureEditObjectV1Response> {
            return ObjectEzsignsignatureApiFp(configuration).ezsignsignatureEditObjectV1(pkiEzsignsignatureID, ezsignsignatureEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature\'s children IDs
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID: number, options?: any): AxiosPromise<void> {
            return ObjectEzsignsignatureApiFp(configuration).ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignsignature
         * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignsignatureGetObjectV1(pkiEzsignsignatureID: number, options?: any): AxiosPromise<EzsignsignatureGetObjectV1Response> {
            return ObjectEzsignsignatureApiFp(configuration).ezsignsignatureGetObjectV1(pkiEzsignsignatureID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsignsignatureApi - object-oriented interface
 * @export
 * @class ObjectEzsignsignatureApi
 * @extends {BaseAPI}
 */
export class ObjectEzsignsignatureApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsignsignature
     * @param {Array<EzsignsignatureCreateObjectV1Request>} ezsignsignatureCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignsignatureApi
     */
    public ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request: Array<EzsignsignatureCreateObjectV1Request>, options?: any) {
        return ObjectEzsignsignatureApiFp(this.configuration).ezsignsignatureCreateObjectV1(ezsignsignatureCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsignsignature
     * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignsignatureApi
     */
    public ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID: number, options?: any) {
        return ObjectEzsignsignatureApiFp(this.configuration).ezsignsignatureDeleteObjectV1(pkiEzsignsignatureID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing Ezsignsignature
     * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
     * @param {EzsignsignatureEditObjectV1Request} ezsignsignatureEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignsignatureApi
     */
    public ezsignsignatureEditObjectV1(pkiEzsignsignatureID: number, ezsignsignatureEditObjectV1Request: EzsignsignatureEditObjectV1Request, options?: any) {
        return ObjectEzsignsignatureApiFp(this.configuration).ezsignsignatureEditObjectV1(pkiEzsignsignatureID, ezsignsignatureEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignsignature\'s children IDs
     * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignsignatureApi
     */
    public ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID: number, options?: any) {
        return ObjectEzsignsignatureApiFp(this.configuration).ezsignsignatureGetObjectGetChildrenV1(pkiEzsignsignatureID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignsignature
     * @param {number} pkiEzsignsignatureID The unique ID of the Ezsignsignature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignsignatureApi
     */
    public ezsignsignatureGetObjectV1(pkiEzsignsignatureID: number, options?: any) {
        return ObjectEzsignsignatureApiFp(this.configuration).ezsignsignatureGetObjectV1(pkiEzsignsignatureID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectFranchisebrokerApi - axios parameter creator
 * @export
 */
export const ObjectFranchisebrokerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the list of Franchisebrokers to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchisebrokers and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchisebrokers to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchisebrokerGetAutocompleteV1: async (sSelector: 'Active' | 'All', sQuery?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSelector' is not null or undefined
            if (sSelector === null || sSelector === undefined) {
                throw new RequiredError('sSelector','Required parameter sSelector was null or undefined when calling franchisebrokerGetAutocompleteV1.');
            }
            const localVarPath = `/1/object/franchisebroker/getAutocomplete/{sSelector}`
                .replace(`{${"sSelector"}}`, encodeURIComponent(String(sSelector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sQuery !== undefined) {
                localVarQueryParameter['sQuery'] = sQuery;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectFranchisebrokerApi - functional programming interface
 * @export
 */
export const ObjectFranchisebrokerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the list of Franchisebrokers to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchisebrokers and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchisebrokers to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async franchisebrokerGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonGetAutocompleteV1Response>> {
            const localVarAxiosArgs = await ObjectFranchisebrokerApiAxiosParamCreator(configuration).franchisebrokerGetAutocompleteV1(sSelector, sQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectFranchisebrokerApi - factory interface
 * @export
 */
export const ObjectFranchisebrokerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the list of Franchisebrokers to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchisebrokers and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchisebrokers to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchisebrokerGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any): AxiosPromise<CommonGetAutocompleteV1Response> {
            return ObjectFranchisebrokerApiFp(configuration).franchisebrokerGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectFranchisebrokerApi - object-oriented interface
 * @export
 * @class ObjectFranchisebrokerApi
 * @extends {BaseAPI}
 */
export class ObjectFranchisebrokerApi extends BaseAPI {
    /**
     * Get the list of Franchisebrokers to be used in a dropdown or autocomplete control.
     * @summary Retrieve Franchisebrokers and IDs
     * @param {'Active' | 'All'} sSelector The type of Franchisebrokers to return
     * @param {string} [sQuery] Allow to filter on the option value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectFranchisebrokerApi
     */
    public franchisebrokerGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any) {
        return ObjectFranchisebrokerApiFp(this.configuration).franchisebrokerGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectFranchiseofficeApi - axios parameter creator
 * @export
 */
export const ObjectFranchiseofficeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the list of Franchiseoffices to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchiseoffices and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchiseoffices to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchiseofficeGetAutocompleteV1: async (sSelector: 'Active' | 'All', sQuery?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSelector' is not null or undefined
            if (sSelector === null || sSelector === undefined) {
                throw new RequiredError('sSelector','Required parameter sSelector was null or undefined when calling franchiseofficeGetAutocompleteV1.');
            }
            const localVarPath = `/1/object/franchiseoffice/getAutocomplete/{sSelector}`
                .replace(`{${"sSelector"}}`, encodeURIComponent(String(sSelector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sQuery !== undefined) {
                localVarQueryParameter['sQuery'] = sQuery;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectFranchiseofficeApi - functional programming interface
 * @export
 */
export const ObjectFranchiseofficeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the list of Franchiseoffices to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchiseoffices and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchiseoffices to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async franchiseofficeGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonGetAutocompleteV1Response>> {
            const localVarAxiosArgs = await ObjectFranchiseofficeApiAxiosParamCreator(configuration).franchiseofficeGetAutocompleteV1(sSelector, sQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectFranchiseofficeApi - factory interface
 * @export
 */
export const ObjectFranchiseofficeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the list of Franchiseoffices to be used in a dropdown or autocomplete control.
         * @summary Retrieve Franchiseoffices and IDs
         * @param {'Active' | 'All'} sSelector The type of Franchiseoffices to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchiseofficeGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any): AxiosPromise<CommonGetAutocompleteV1Response> {
            return ObjectFranchiseofficeApiFp(configuration).franchiseofficeGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectFranchiseofficeApi - object-oriented interface
 * @export
 * @class ObjectFranchiseofficeApi
 * @extends {BaseAPI}
 */
export class ObjectFranchiseofficeApi extends BaseAPI {
    /**
     * Get the list of Franchiseoffices to be used in a dropdown or autocomplete control.
     * @summary Retrieve Franchiseoffices and IDs
     * @param {'Active' | 'All'} sSelector The type of Franchiseoffices to return
     * @param {string} [sQuery] Allow to filter on the option value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectFranchiseofficeApi
     */
    public franchiseofficeGetAutocompleteV1(sSelector: 'Active' | 'All', sQuery?: string, options?: any) {
        return ObjectFranchiseofficeApiFp(this.configuration).franchiseofficeGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectFranchisereferalincomeApi - axios parameter creator
 * @export
 */
export const ObjectFranchisereferalincomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Franchisereferalincome
         * @param {Array<FranchisereferalincomeCreateObjectV1Request>} franchisereferalincomeCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchisereferalincomeCreateObjectV1: async (franchisereferalincomeCreateObjectV1Request: Array<FranchisereferalincomeCreateObjectV1Request>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'franchisereferalincomeCreateObjectV1Request' is not null or undefined
            if (franchisereferalincomeCreateObjectV1Request === null || franchisereferalincomeCreateObjectV1Request === undefined) {
                throw new RequiredError('franchisereferalincomeCreateObjectV1Request','Required parameter franchisereferalincomeCreateObjectV1Request was null or undefined when calling franchisereferalincomeCreateObjectV1.');
            }
            const localVarPath = `/1/object/franchisereferalincome`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof franchisereferalincomeCreateObjectV1Request !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(franchisereferalincomeCreateObjectV1Request !== undefined ? franchisereferalincomeCreateObjectV1Request : {})
                : (franchisereferalincomeCreateObjectV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectFranchisereferalincomeApi - functional programming interface
 * @export
 */
export const ObjectFranchisereferalincomeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Franchisereferalincome
         * @param {Array<FranchisereferalincomeCreateObjectV1Request>} franchisereferalincomeCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request: Array<FranchisereferalincomeCreateObjectV1Request>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FranchisereferalincomeCreateObjectV1Response>> {
            const localVarAxiosArgs = await ObjectFranchisereferalincomeApiAxiosParamCreator(configuration).franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectFranchisereferalincomeApi - factory interface
 * @export
 */
export const ObjectFranchisereferalincomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Franchisereferalincome
         * @param {Array<FranchisereferalincomeCreateObjectV1Request>} franchisereferalincomeCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request: Array<FranchisereferalincomeCreateObjectV1Request>, options?: any): AxiosPromise<FranchisereferalincomeCreateObjectV1Response> {
            return ObjectFranchisereferalincomeApiFp(configuration).franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectFranchisereferalincomeApi - object-oriented interface
 * @export
 * @class ObjectFranchisereferalincomeApi
 * @extends {BaseAPI}
 */
export class ObjectFranchisereferalincomeApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Franchisereferalincome
     * @param {Array<FranchisereferalincomeCreateObjectV1Request>} franchisereferalincomeCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectFranchisereferalincomeApi
     */
    public franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request: Array<FranchisereferalincomeCreateObjectV1Request>, options?: any) {
        return ObjectFranchisereferalincomeApiFp(this.configuration).franchisereferalincomeCreateObjectV1(franchisereferalincomeCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectPeriodApi - axios parameter creator
 * @export
 */
export const ObjectPeriodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the list of Periods to be used in a dropdown or autocomplete control.
         * @summary Retrieve Periods and IDs
         * @param {'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear'} sSelector The types of Periods to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        periodGetAutocompleteV1: async (sSelector: 'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear', sQuery?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSelector' is not null or undefined
            if (sSelector === null || sSelector === undefined) {
                throw new RequiredError('sSelector','Required parameter sSelector was null or undefined when calling periodGetAutocompleteV1.');
            }
            const localVarPath = `/1/object/period/getAutocomplete/{sSelector}`
                .replace(`{${"sSelector"}}`, encodeURIComponent(String(sSelector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sQuery !== undefined) {
                localVarQueryParameter['sQuery'] = sQuery;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectPeriodApi - functional programming interface
 * @export
 */
export const ObjectPeriodApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the list of Periods to be used in a dropdown or autocomplete control.
         * @summary Retrieve Periods and IDs
         * @param {'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear'} sSelector The types of Periods to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async periodGetAutocompleteV1(sSelector: 'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear', sQuery?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonGetAutocompleteV1Response>> {
            const localVarAxiosArgs = await ObjectPeriodApiAxiosParamCreator(configuration).periodGetAutocompleteV1(sSelector, sQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectPeriodApi - factory interface
 * @export
 */
export const ObjectPeriodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the list of Periods to be used in a dropdown or autocomplete control.
         * @summary Retrieve Periods and IDs
         * @param {'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear'} sSelector The types of Periods to return
         * @param {string} [sQuery] Allow to filter on the option value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        periodGetAutocompleteV1(sSelector: 'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear', sQuery?: string, options?: any): AxiosPromise<CommonGetAutocompleteV1Response> {
            return ObjectPeriodApiFp(configuration).periodGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectPeriodApi - object-oriented interface
 * @export
 * @class ObjectPeriodApi
 * @extends {BaseAPI}
 */
export class ObjectPeriodApi extends BaseAPI {
    /**
     * Get the list of Periods to be used in a dropdown or autocomplete control.
     * @summary Retrieve Periods and IDs
     * @param {'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear'} sSelector The types of Periods to return
     * @param {string} [sQuery] Allow to filter on the option value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectPeriodApi
     */
    public periodGetAutocompleteV1(sSelector: 'ActiveNormal' | 'ActiveNormalAndEndOfYear' | 'AllNormal' | 'AllNormalAndEndOfYear', sQuery?: string, options?: any) {
        return ObjectPeriodApiFp(this.configuration).periodGetAutocompleteV1(sSelector, sQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


